<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linuxes on Realjf&#39;s blog</title>
    <link>https://realjf.io/linux/</link>
    <description>Recent content in Linuxes on Realjf&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 11 May 2020 16:20:44 +0800</lastBuildDate>
    
	<atom:link href="https://realjf.io/linux/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>免秘钥登录配置 Ssh Login Nopassword</title>
      <link>https://realjf.io/linux/ssh-login-nopassword/</link>
      <pubDate>Mon, 11 May 2020 16:20:44 +0800</pubDate>
      
      <guid>https://realjf.io/linux/ssh-login-nopassword/</guid>
      <description>方法一 在一个节点生成公钥，然后利用ssh-copy-id复制到各节点
ssh-keygen -t rsa -b 4096 -P &#39;&#39; -f ~/.ssh/id_rsa -C &amp;quot;备注&amp;quot; # 复制到各节点 ssh-copy-id node2 ssh-copy-id node3 ssh-copy-id node4 # 其他节点重复上述操作，实现各节点之间可以相互免密登录  方法二 也可以使用shell脚本，需要提前安装好expect
yum install expect -y  autoSSH.sh
#!/bin/bash ## 脚本接收的参数，也就是要互相配置 SSH 免密登录的服务器列表参数 BASE_HOST_LIST=$* ## 密码，默认用户是当前运行脚本的用户，比如 root 用户 ## 这里改成你的用户对应的密码 BASE_PASSWORD=&amp;quot;root&amp;quot; ## shell 函数：模拟 SSH 公钥私钥文件生成的人机交互过程 sshkeygen(){ expect -c &amp;quot; spawn ssh-keygen expect { \&amp;quot;ssh/id_rsa):\&amp;quot; {send \&amp;quot;\r\&amp;quot;;exp_continue} \&amp;quot;passphrase):\&amp;quot; {send \&amp;quot;\r\&amp;quot;;exp_continue} \&amp;quot;again:\&amp;quot; {send \&amp;quot;\r\&amp;quot;;exp_continue} } &amp;quot; } ## shell 函数：模拟配置 SSH 免密登录过程的人机交互过程 sshcopyid(){ expect -c &amp;quot; spawn ssh-copy-id $1 expect { \&amp;quot;(yes/no)?</description>
    </item>
    
    <item>
      <title>Jdk 8 安装</title>
      <link>https://realjf.io/linux/jdk-8u131/</link>
      <pubDate>Mon, 11 May 2020 15:46:10 +0800</pubDate>
      
      <guid>https://realjf.io/linux/jdk-8u131/</guid>
      <description> jdk下载地址： https://www.oracle.com/java/technologies/javase-jdk8-downloads.html
或者：https://www.oracle.com/java/technologies/oracle-java-archive-downloads.html
这里提供百度云下载：链接: https://pan.baidu.com/s/1_fSe_nkdoZ_QhidbQyZ1ig 提取码: ttpw
准备环境  centos7 虚拟机  手动安装 检查系统是否已经安装了jdk，有就卸载默认的jdk rpm -qa | grep jdk ava-1.6.0-openjdk-1.6.0.35-1.13.7.1.el6_6.x86_64 java-1.7.0-openjdk-1.7.0.79-2.5.5.4.el6.x86_64 [root@node1 ~]# rpm -e --nodeps java-1.6.0-openjdk-1.6.0.35-1.13.7.1.el6_6.x86_64 [root@node1 ~]# rpm -e --nodeps java-1.7.0-openjdk-1.7.0.79-2.5.5.4.el6.x86_64  下载安装jdk wget https://download.oracle.com/otn/java/jdk/8u251-b08/3d5a2bb8f8d4428bbe94aed7ec7ae784/jdk-8u251-linux-x64.tar.gz tar zxvf jdk-8u251-linux-x64.tar.gz -C /usr/local # 配置环境变量 vi /etc/profile export JAVA_HOME=/usr/local/jdk1.8.0_251 export PATH=$PATH:$JAVA_HOME/bin # 保存退出 :wq source /etc/profile # 验证 java -version  </description>
    </item>
    
    <item>
      <title>debian 系统启动进入Busybox Initramfs界面</title>
      <link>https://realjf.io/linux/error/boot-into-busybox-initramfs/</link>
      <pubDate>Thu, 20 Feb 2020 22:07:19 +0800</pubDate>
      
      <guid>https://realjf.io/linux/error/boot-into-busybox-initramfs/</guid>
      <description>首先说下背景  系统环境： debian 9  问题描述 今天使用vmware workstation的时候，提示操作失败，且提示为文件系统只读。 奇怪？怎么突然进入可读了，猜想可能文件系统哪里损坏导致进入只读保护模式。
所以重新启动，之后进入了busybox界面的Initramfs界面，输入help可以查看相应命令。 我使用exit直接退出看能否重新进入，发现还是提示错误，无法进入
 busybox可以提供一个比较完善的shell工具集以及运行环境，同时可以引导程序进入系统。
 解决 在多次尝试重启无果后，重新查看错误提示，提到了/dev/mapper/realjf&amp;ndash;vg-root的文件系统， 可能是文件系统损坏了，所以开始检查修复文件系统：fsck /dev/mapper/realjf&amp;ndash;vg-root， 然后系统开始检查文件系统损坏情况，并尝试进行修复，多次输入&amp;rsquo;y&amp;rsquo;后，提示文件系统修复完成， 然后重新输入exit看是否能重新进入系统，发现已经可以进入系统了。</description>
    </item>
    
    <item>
      <title>linux系统资源设置 之 Ulimit 命令</title>
      <link>https://realjf.io/linux/command/ulimit/</link>
      <pubDate>Tue, 10 Dec 2019 14:14:25 +0800</pubDate>
      
      <guid>https://realjf.io/linux/command/ulimit/</guid>
      <description>根据linux 开发手册， ulimit 设置和获取用户的资源限制
ulimit 参数说明
   选项 说明     -t 最大 cpu 占用时间 (单位是秒)   -f 进程创建文件大小的最大值 (单位是blocks)   -d 进程最大的数据段的大小，以kbytes为单位   -s 线程栈的大小，以kbytes为单位   -c 最大的core文件的大小，以blocks为单位   -m 最大内存大小，以kbytes为单位   -u 用户最大的可用的进程数   -n 可以打开的最大文件描述符数量   -l 最大可加锁内存大小，以kbytes为单位   -v 进程最大可用的虚拟内存，以kbytes为单位   -x    -i    -q    -e    -r    -N    -p 管道缓冲区的大小，以kbytes为单位   -a 显示所有资源限制的设定   -S 设定资源的弹性限制    </description>
    </item>
    
  </channel>
</rss>