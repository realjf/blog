<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Weak_ptr on Realjf&#39;s blog</title>
    <link>https://realjf.io/tags/weak_ptr/</link>
    <description>Recent content in Weak_ptr on Realjf&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 09 Mar 2021 17:41:32 +0800</lastBuildDate>
    
	<atom:link href="https://realjf.io/tags/weak_ptr/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>如何使用weak_ptr? How to Use Weak Pointer</title>
      <link>https://realjf.io/cpp/how-to-use-weak-pointer/</link>
      <pubDate>Tue, 09 Mar 2021 17:41:32 +0800</pubDate>
      
      <guid>https://realjf.io/cpp/how-to-use-weak-pointer/</guid>
      <description>如何使用weak_ptr？ 使用shared_ptr能自动释放“不再被需要的对象”的资源，避免资源泄漏。但是有以下两种情况可能share_ptr无法正常运作
 环式指向cyclic reference，如果两对象使用shared_ptr互相指向对方，而一旦不存在其他reference指向它们时，你想释放它们和相应资源时，shared_ptr不会释放数据，因为每个对象的use_count()仍是1，此时你或许会想使用普通的指针，但这样做却要自行管理是释放相应资源了。 还有一种是你明确想共享但不愿拥有某对象的情况下，你要的语义是：reference的寿命比其所指向对象的寿命更长，因此，shared_ptr绝不释放对象，而普通指针可能不会注意到他们指向的对象已经不再有效，导致“访问已被释放的对象”的风险。  解决方案 标准库提供了类weak_ptr，允许你“共享但不拥有”某对象（即可以访问对象数据，但是不能操作对象）。这个weak_ptr建立起一个shared_ptr，一旦最末尾一个拥有该对象的shared_pointer失去了拥有权，任何weak pointer都会自动成空。
因此，在默认构造函数和copy构造函数之外，weak_ptr只提供“接收一个shared_ptr”的构造函数。
你不能使用操作符*和-&amp;gt;访问weak_ptr指向的对象，而是必须另外建立一个shared pointer。理由如下：
 在weak pointer之外建立一个shared pointer可因此检查是否扔存在一个相应对象，如果不，操作会抛出异常或建立一个empty shared pointer（实际究竟哪种行为乃取决于你所执行的是哪一种操作）。 当指向的对象正被处理时，shared pointer无法被释放  基于以上理由，weak_ptr只提供小量操作，只够用来创建、复制、赋值weak pointer。以及转换为一个shared pointer，或检查自己是否指向某对象。
weak_ptr使用示例 首先是使用shared_ptr构建环形指向引用。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;memory&amp;gt; using namespace std; class Person { public: string name; shared_ptr&amp;lt;Person&amp;gt; mother; shared_ptr&amp;lt;Person&amp;gt; father; vector&amp;lt;shared_ptr&amp;lt;Person&amp;gt;&amp;gt; kids; Person(const string&amp;amp; n, shared_ptr&amp;lt;Person&amp;gt; m= nullptr, shared_ptr&amp;lt;Person&amp;gt; f =nullptr) : name(n), mother(m), father(f) { } ~Person(){ cout &amp;lt;&amp;lt; &amp;quot;delete &amp;quot; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; endl; } }; shared_ptr&amp;lt;Person&amp;gt; initFamily(const string&amp;amp; name) { shared_ptr&amp;lt;Person&amp;gt; mom(new Person(name+&amp;quot;&#39;s mom&amp;quot;)); shared_ptr&amp;lt;Person&amp;gt; dad(new Person(name+&amp;quot;&#39;s dad&amp;quot;)); shared_ptr&amp;lt;Person&amp;gt; kid(new Person(name, mom, dad)); mom-&amp;gt;kids.</description>
    </item>
    
  </channel>
</rss>