<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>timeout on Realjf&#39;s blog</title>
    <link>https://realjf.io/tags/timeout/</link>
    <description>Recent content in timeout on Realjf&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 21 Nov 2019 17:10:13 +0800</lastBuildDate>
    
	<atom:link href="https://realjf.io/tags/timeout/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Golang 并发编程 之 超时处理</title>
      <link>https://realjf.io/posts/golang-concurrency-timeout/</link>
      <pubDate>Thu, 21 Nov 2019 17:10:13 +0800</pubDate>
      
      <guid>https://realjf.io/posts/golang-concurrency-timeout/</guid>
      <description>并发编程中的超时处理 在并发编程中，要放弃运行时间太长的同步调用，请使用带有time.After的select语句，如下：
import ( &amp;#34;errors&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) func main() { var timeoutNanoseconds time.Duration = 5 * time.Second c := make(chan error, 1) go func() { time.Sleep(20 * time.Second) c &amp;lt;- errors.New(&amp;#34;error&amp;#34;) } () select { case err := &amp;lt;-c: // use err and reply 	fmt.Println(err) case &amp;lt;-time.After(timeoutNanoseconds): // call timed out 	fmt.Println(&amp;#34;timeout...&amp;#34;) } } 以上代码在超时5秒后退出</description>
    </item>
    
  </channel>
</rss>