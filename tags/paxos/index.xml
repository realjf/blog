<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Paxos on Realjf&#39;s blog</title>
    <link>https://realjf.io/tags/paxos/</link>
    <description>Recent content in Paxos on Realjf&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 21 Apr 2020 10:05:32 +0800</lastBuildDate>
    
	<atom:link href="https://realjf.io/tags/paxos/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>分布式一致性协议 2PC和3PC Paxos（Distributed Consistency Protocol）</title>
      <link>https://realjf.io/posts/distributed-consistency-protocol/</link>
      <pubDate>Tue, 21 Apr 2020 10:05:32 +0800</pubDate>
      
      <guid>https://realjf.io/posts/distributed-consistency-protocol/</guid>
      <description>分布式一致性协议在实践过程中产生了许多优秀的协议和算法，其中就包括两阶段提交、三阶段提交协议和Paxos算法。
2PC：两阶段提交 两阶段提交，主要由协调者和参与者组成，协调者负责协调所有参与者是否提交最后结果，并保证各参与者之间的结果一致（提交或者回滚）。
阶段一：提交事务请求阶段  协调者向所有参与者发送事务内容，询问是否可以执行事务提交操作，并等待各参与者的回应 各参与者节点执行事务操作，并将undo和redo信息记录事务日志中 如果参与者执行了事务操作，那么就反馈给协调者yes响应，表示事务可以执行，否则返回no，表示事务不可以执行。  阶段二：执行事务提交阶段 阶段二主要是对各参与者反馈的情况决定是否继续进行事务提交操作，或者回滚。 主要包括两种情况：
第一种：执行事务提交 假如协调者从所有的参与者获得的反馈都是yes，那么就执行事务提交。
 发送提交请求，协调者向所有参与者节点发送commit请求 事务提交，参与者接收到commit请求后，会正式执行事务提交，并在完成后释放整个事务执行期间占用的资源 反馈事务提交结果，提交完成后，向协调者发送ack信息 完成事务，协调者接收到所有参与者的ack信息后，完成事务。  第二种：中断事务 假如任何一个参与者向协调者反馈了no，或者在等待超时之后，协调者仍然没有接收到所有参与者的反馈，那么就中断事务。
 发送回滚请求，协调者向所有参与者节点发送rollback请求 事务回滚，参与者接收到rollback请求后，利用第一阶段中记录的undo信息来执行事务回滚，并在完成回滚后释放在整个事务期间占用的资源 反馈事务回滚结果，参与者在完成事务回滚之后，向协调者发送ack信息 中断事务，协调者接收到所有的参与者反馈的ack信息后，完成事务中断  两阶段提交优缺点  优点：原理简单，实现方便 缺点：同步阻塞，单点问题、脑裂、容错机制简单  3PC：三阶段提交 三阶段提交可说是2PC的改进版，其将二阶段提交协议的提交事务请求过程一分为二，形成了CanCommit、PreCommit和do Commit三个阶段组成的事务处理协议。
阶段一：CanCommit  事务询问，协调者向所有的参与者发送一个包含事务内容的canCommit请求，询问是否可以执行事务提交操作，并开始等待各参与者的响应。 各参与者向协调者反馈事务询问的响应，参与者在接收到来自协调者的canCommit请求后，正常情况是，如果其自身认为可以顺利执行事务，那么会反馈yes，并进入预备状态，否则反馈no  阶段二：PreCommit 阶段二，协调者会根据各参与者的反馈情况来决定是否可以进行事务的PreCommit操作，正常情况，包括两种：
第一种：执行事务预提交 假如协调者从所有的参与者获得的反馈都是yes，那么就会执行事务预提交。
 发送预提交请求，协调者向所有参与者节点发送preCommit请求，并进入prepared阶段。 事务预提交，参与者接收到preCommit请求后，会执行事务操作，并将undo和redo信息记录到事务日志中。 各参与者向协调者反馈事务执行的响应，如果参与者成功执行了事务操作，那么就反馈给协调者ack响应，同时等待最终指令：提交（commit）或终止（abort）  第二种：中断事务 如果协调者收到任何一个参与者反馈了no，或者等待超时之后，仍然无法接收到所有参与者的反馈，那么就中断事务。
 发送中断请求，协调者向所有参与者节点发送abort请求 中断事务，无论是收到来自协调者的abort，或者是等待协调者请求过程中出现超时，参与者都会中断事务。  阶段三：doCommit 这个阶段是真正执行事务提交，存在两种可能
第一种：执行提交  发送提交请求，假设协调者处于正常状态，并且收到了所有参与者的ack信息，那么它就从预提交状态转换到提交状态，并向所有参与者发送doCommit请求 事务提交，参与者接收到doCommit请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的资源。 反馈事务提交结果，参与者在完成事务提交之后，向协调者发送ack信息 完成事务，协调者接收到所有参与者的反馈ack信息后，完成事务。  第二种：中断事务 在这个阶段，假设协调者正常，并且有任意一个参与者反馈了no，或者等待超时之后，协调者无法接收到所有参与者的响应，那么就中断事务。
 发送中断请求，协调者向所有参与者节点发送abort请求 事务回滚，参与者接收到abort请求后，会利用其在阶段二中记录的undo信息来执行回滚，并在完成回滚之后释放事务执行期间占用的资源。 反馈事务回滚结果，事务完成回滚之后，向协调者发送ack信息 中断事务，协调者接收到所有参与者反馈的的ack信息后，中断事务  注意：一旦进入阶段三，可能有两种故障</description>
    </item>
    
  </channel>
</rss>