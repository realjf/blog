<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>assembly on Realjf&#39;s blog</title>
    <link>https://realjf.io/tags/assembly/</link>
    <description>Recent content in assembly on Realjf&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 31 May 2020 03:23:19 +0800</lastBuildDate>
    
	<atom:link href="https://realjf.io/tags/assembly/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>nasm汇编之数值 Numbers</title>
      <link>https://realjf.io/assembly/numbers/</link>
      <pubDate>Sun, 31 May 2020 03:23:19 +0800</pubDate>
      
      <guid>https://realjf.io/assembly/numbers/</guid>
      <description>数值数据通常用二进制表示。算术指令对二进制数据进行操作。当数字显示在屏幕上或通过键盘输入时，它们为ASCII格式
此类转换会产生开销，并且汇编语言编程允许以更有效的方式以二进制形式处理数字。小数可以两种形式表示
 ASCII格式 BCD或者二进制编码的十进制形式  ASCII表示 在ASCII表示中，十进制数字存储为ASCII字符串
有四条指令以ASCII表示形式处理数字
 AAA ASCII Adjust After Addition AAS ASCII Adjust After Subtraction AAM ASCII Adjust After Multiplication AAD ASCII Adjust Before Division  这些指令不使用任何操作数，并假定所需的操作数位于AL寄存器中
示例
section	.text global _start ;must be declared for using gcc 	_start:	;tell linker entry point  sub ah, ah mov al, &amp;#39;9&amp;#39; sub al, &amp;#39;3&amp;#39; aas or al, 30h mov [res], ax mov	edx,len	;message length  mov	ecx,msg	;message to write  mov	ebx,1	;file descriptor (stdout)  mov	eax,4	;system call number (sys_write)  int	0x80	;call kernel 	mov	edx,1	;message length  mov	ecx,res	;message to write  mov	ebx,1	;file descriptor (stdout)  mov	eax,4	;system call number (sys_write)  int	0x80	;call kernel 	mov	eax,1	;system call number (sys_exit)  int	0x80	;call kernel 	section	.</description>
    </item>
    
    <item>
      <title>nasm汇编之循环 Loops</title>
      <link>https://realjf.io/assembly/loops/</link>
      <pubDate>Sun, 31 May 2020 03:23:13 +0800</pubDate>
      
      <guid>https://realjf.io/assembly/loops/</guid>
      <description>JMP指令可用于实现循环。例如，以下代码段可用于执行循环主体10次
MOV	CL, 10 L1: &amp;lt;LOOP-BODY&amp;gt; DEC	CL JNZ	L1 但是，处理器指令集包括一组用于实现迭代的循环指令。基本的LOOP指令具有以下语法
LOOP label 其中，label是标识目标指令的目标标签，如跳转指令中所述。 LOOP指令假定ECX寄存器包含循环计数。 当执行循环指令时，ECX寄存器递减，并且控制跳至目标标签，直到ECX寄存器的值（即计数器达到零）为止。
示例
Live Demo section	.text global _start ;must be declared for using gcc 	_start:	;tell linker entry point  mov ecx,10 mov eax, &amp;#39;1&amp;#39; l1: mov [num], eax mov eax, 4 mov ebx, 1 push ecx mov ecx, num mov edx, 1 int 0x80 mov eax, [num] sub eax, &amp;#39;0&amp;#39; inc eax add eax, &amp;#39;0&amp;#39; pop ecx loop l1 mov eax,1 ;system call number (sys_exit)  int 0x80 ;call kernel section	.</description>
    </item>
    
    <item>
      <title>nasm汇编之条件判断 Conditions</title>
      <link>https://realjf.io/assembly/conditions/</link>
      <pubDate>Sun, 31 May 2020 03:23:03 +0800</pubDate>
      
      <guid>https://realjf.io/assembly/conditions/</guid>
      <description>汇编语言中的条件执行是通过几个循环和分支指令来完成的。这些指令可以更改程序中的控制流。在两种情况下观察到条件执行
无条件跳转 这是通过JMP指令执行的。条件执行通常涉及将控制权转移到不遵循当前执行指令的指令的地址。 控制权的转移可以是前进，执行新指令集，也可以是后退，重新执行相同的步骤
有条件的跳转 这取决于条件由一组跳转指令j 执行。条件指令通过中断顺序流程来转移控制，而它们通过更改IP中的偏移值来完成
cmp指令 CMP指令比较两个操作数。它通常用于条件执行中。该指令基本上从另一个操作数中减去一个操作数，以比较操作数是否相等。 它不会干扰目标或源操作数。它与条件跳转指令一起用于决策。
语法
CMP destination, source CMP比较两个数字数据字段。目标操作数可以在寄存器中或在内存中。源操作数可以是常量（立即数）数据，寄存器或内存
示例
CMP DX,	00 ; Compare the DX value with zero JE L7 ; If yes, then jump to label L7 . . L7: ... CMP通常用于比较计数器值是否已达到需要运行循环的次数。考虑以下典型条件
INC	EDX CMP	EDX, 10	; Compares whether the counter has reached 10 JLE	LP1 ; If it is less than or equal to 10, then jump to LP1 无条件跳转 这是通过JMP指令执行的。条件执行通常涉及将控制权转移到不遵循当前执行指令的指令的地址。</description>
    </item>
    
    <item>
      <title>nasm汇编之逻辑指令 Logical Instructions</title>
      <link>https://realjf.io/assembly/logical-instructions/</link>
      <pubDate>Sun, 31 May 2020 02:16:58 +0800</pubDate>
      
      <guid>https://realjf.io/assembly/logical-instructions/</guid>
      <description>处理器指令集提供指令AND，OR，XOR，TEST和NOT布尔逻辑，它们根据程序的需要测试，设置和清除位。
   序号 指令 格式     1 AND AND operand1, operand2   2 OR OR operand1, operand2   3 XOR XOR operand1, operand2   4 TEST TEST operand1, operand2   5 NOT NOT operand1   在所有情况下，第一个操作数都可以在寄存器或内存中。第二个操作数可以是寄存器/内存，也可以是立即数（常量）。     但是，内存到内存操作是不可能的。这些指令比较或匹配操作数的位，并设置CF，OF，PF，SF和ZF标志。      and指令 AND指令用于通过执行按位AND运算来支持逻辑表达式。如果两个操作数的匹配位均为1，则按位AND运算将返回1，否则返回0
AND操作可用于清除一个或多个位。例如，假设BL寄存器包含00111010。如果需要将高阶位清除为零，则将其与0FH
AND	BL, 0FH ; This sets BL to 0000 1010 如果要检查给定数字是奇数还是偶数，一个简单的测试将是检查数字的最低有效位。如果为1，则数字为奇数，否则为偶数。</description>
    </item>
    
    <item>
      <title>nasm汇编之算术指令 Arithmetic Instructions</title>
      <link>https://realjf.io/assembly/arithmetic-instructions/</link>
      <pubDate>Sun, 31 May 2020 02:15:46 +0800</pubDate>
      
      <guid>https://realjf.io/assembly/arithmetic-instructions/</guid>
      <description>inc 指令 INC指令用于将操作数加1。它适用于可以在寄存器或内存中的单个操作数
语法
INC destination 操作数目的地可以是8位，16位或32位操作数
示例
INC EBX	; Increments 32-bit register INC DL ; Increments 8-bit register INC [count] ; Increments the count variable dec指令 DEC指令用于将操作数减1。它对可以在寄存器或内存中的单个操作数起作用
语法
DEC destination 操作数目的地可以是8位，16位或32位操作数。
示例
segment .data count dw 0 value db 15 segment .text inc [count] dec [value] mov ebx, count inc word [ebx] mov esi, value dec byte [esi] add和sub指令 ADD和SUB指令用于对字节，字和双字大小的二进制数据进行简单的加/减，即分别用于添加或减去8位，16位或32位操作数
语法
ADD/SUB	destination, source ADD / SUB指令可以在
 寄存器到寄存器 内存到寄存器 寄存器到内存 寄存器到常量 内存到常量  与其他指令一样，使用ADD/SUB指令也无法进行存储器到存储器的操作。 ADD或SUB操作设置或清除溢出和进位标志。</description>
    </item>
    
    <item>
      <title>nasm汇编之常量 Constants</title>
      <link>https://realjf.io/assembly/constants/</link>
      <pubDate>Sun, 31 May 2020 02:09:10 +0800</pubDate>
      
      <guid>https://realjf.io/assembly/constants/</guid>
      <description>NASM提供了多个定义常量的指令。在前面的章节中，我们已经使用过EQU指令。我们将特别讨论三个指令
 EQU %assign %define  EQU指令 EQU指令用于定义常量。 EQU指令的语法如下
CONSTANT_NAME EQU expression 示例
TOTAL_STUDENTS equ 50 EQU语句的操作数可以是表达式
LENGTH equ 20 WIDTH equ 10 AREA equ length * width 示例
Live Demo SYS_EXIT equ 1 SYS_WRITE equ 4 STDIN equ 0 STDOUT equ 1 section	.text global _start ;must be declared for using gcc 	_start: ;tell linker entry point  mov eax, SYS_WRITE mov ebx, STDOUT mov ecx, msg1 mov edx, len1 int 0x80 mov eax, SYS_WRITE mov ebx, STDOUT mov ecx, msg2 mov edx, len2 int 0x80 mov eax, SYS_WRITE mov ebx, STDOUT mov ecx, msg3 mov edx, len3 int 0x80 mov eax,SYS_EXIT ;system call number (sys_exit)  int 0x80 ;call kernel  section	.</description>
    </item>
    
    <item>
      <title>nasm汇编之变量 Variables</title>
      <link>https://realjf.io/assembly/variables/</link>
      <pubDate>Sun, 31 May 2020 01:50:22 +0800</pubDate>
      
      <guid>https://realjf.io/assembly/variables/</guid>
      <description>NASM提供了各种定义指令来为变量保留存储空间。 define assembler指令用于分配存储空间。它可以用于保留以及初始化一个或多个字节
为初始化数据分配存储空间 初始化数据的存储分配语句的语法为
[variable-name] define-directive initial-value [,initial-value]... 其中，变量名是每个存储空间的标识符。汇编器为数据段中定义的每个变量名称关联一个偏移值。
五种基本类型指令
   指令 说明 存储空间     DB 定义字节 1 byte   DW 定义字 2 bytes   DD 定义双字 4 bytes   DQ 定义四字 8 bytes   DT 定义10字 10 bytes    示例
choice	DB	&amp;#39;y&amp;#39; number	DW	12345 neg_number	DW	-12345 big_number	DQ	123456789 real_number1	DD	1.234 real_number2	DQ	123.</description>
    </item>
    
    <item>
      <title>nasm汇编之寻址模式 Addressing Modes</title>
      <link>https://realjf.io/assembly/address-modes/</link>
      <pubDate>Sun, 31 May 2020 01:05:08 +0800</pubDate>
      
      <guid>https://realjf.io/assembly/address-modes/</guid>
      <description>大多数汇编语言指令都需要处理操作数。操作数地址提供了要处理的数据存储的位置。一些指令不需要操作数，而另一些指令则可能需要一个，两个或三个操作数
当一条指令需要两个操作数时，第一个操作数通常是目的地，可能是寄存器或存储器地址，第二个操作数是源。 源包含要传递的数据（立即寻址）或数据的地址（在寄存器或存储器中）。通常，操作后源数据保持不变。
寻址的三种基本模式是
 寄存器寻址 立即寻址 内存寻址  寄存器寻址 在这种寻址模式下，寄存器包含操作数。根据指令，寄存器可以是第一操作数，第二操作数或两者。
MOV DX, TAX_RATE ; Register in first operand MOV COUNT, CX	; Register in second operand MOV EAX, EBX	; Both the operands are in registers 由于寄存器之间的数据处理不涉及内存，因此可以最快地处理数据
立即寻址 立即数操作数具有常数值或表达式。当具有两个操作数的指令使用立即寻址时，第一个操作数可以是寄存器或存储器位置，而第二个操作数是立即数。第一个操作数定义数据的长度。
BYTE_VALUE DB 150 ; A byte value is defined WORD_VALUE DW 300 ; A word value is defined ADD BYTE_VALUE, 65 ; An immediate operand 65 is added MOV AX, 45H ; Immediate constant 45H is transferred to AX 直接内存寻址 在内存寻址模式下指定操作数时，通常需要直接访问主存储器，通常是数据段。这种寻址方式导致数据处理速度变慢。 为了找到数据在内存中的确切位置，我们需要段起始地址（通常在DS寄存器中找到）和偏移值。此偏移值也称为有效地址。</description>
    </item>
    
    <item>
      <title>nasm汇编之系统调用 System Calls</title>
      <link>https://realjf.io/assembly/system-calls/</link>
      <pubDate>Sun, 31 May 2020 00:53:19 +0800</pubDate>
      
      <guid>https://realjf.io/assembly/system-calls/</guid>
      <description>系统调用是用户空间和内核空间之间接口的API。我们已经使用了系统调用。 sys_write和sys_exit，分别用于写入屏幕和退出程序
linux 系统调用 您可以在汇编程序中使用Linux系统调用。您需要按照以下步骤在程序中使用Linux系统调用
 将系统调用编号放入EAX寄存器中 将系统调用的参数存放到EBX,ECX等寄存器 调用相关的中断 结果通常在EAX寄存器中返回  有六个寄存器，用于存储所用系统调用的参数。这些是EBX，ECX，EDX，ESI，EDI和EBP。 这些寄存器采用从EBX寄存器开始的连续参数。如果有六个以上的自变量，则第一个自变量的存储位置将存储在EBX寄存器中
以下代码段显示了系统调用sys_exit的使用
mov	eax,1	; system call number (sys_exit) int	0x80	; call kernel 以下代码段显示了系统调用sys_write的使用
mov	edx,4	; message length mov	ecx,msg	; message to write mov	ebx,1	; file descriptor (stdout) mov	eax,4	; system call number (sys_write) int	0x80	; call kernel 所有系统调用及其编号（在调用int 80h之前放入EAX的值）都列在/usr/include/asm/unistd.h中
下表显示了使用的一些系统调用
   %eax name %ebx %ecx %edx %esx %edi     1 sys_exit int - - - -   2 sys_fork struct pt_regs - - - -   3 sys_read unsigned int char * size_t - -   4 sys_write unsigned int const char * size_t - -    示例 section .</description>
    </item>
    
    <item>
      <title>nasm汇编之内存段 Memory Segments</title>
      <link>https://realjf.io/assembly/memory-segments/</link>
      <pubDate>Sun, 31 May 2020 00:33:36 +0800</pubDate>
      
      <guid>https://realjf.io/assembly/memory-segments/</guid>
      <description>汇编程序的三个节.data、.bss、.text。这些部分也代表各种内存段。
如果将section关键字替换为segment，则会得到相同的结果。试试下面的代码
segment .text	;code segment  global _start ;must be declared for linker 	_start:	;tell linker entry point  mov edx,len	;message length  mov ecx,msg ;message to write  mov ebx,1	;file descriptor (stdout)  mov eax,4	;system call number (sys_write)  int 0x80	;call kernel  mov eax,1 ;system call number (sys_exit)  int 0x80	;call kernel  segment .data ;data segment msg	db &amp;#39;Hello, world!&amp;#39;,0xa ;our dear string len	equ	$ - msg ;length of our dear string 内存段 分段存储器模型将系统存储器分为独立的分段组，这些分段由位于分段寄存器中的指针引用。每个细分用于包含特定类型的数据。 一个段用于包含指令代码，另一段用于存储数据元素，第三段用于保留程序堆栈。</description>
    </item>
    
    <item>
      <title>nasm汇编之基础语法 Basic Syntax</title>
      <link>https://realjf.io/assembly/basic-syntax/</link>
      <pubDate>Sun, 31 May 2020 00:20:08 +0800</pubDate>
      
      <guid>https://realjf.io/assembly/basic-syntax/</guid>
      <description>一个汇编程序可以被分成三个sections：
 data section bss section text section  data section data 部分用于声明初始化的数据或常量。该数据在运行时不会更改。您可以在本节中声明各种常量值，文件名或缓冲区大小等
section .data bss section bss部分用于声明变量。声明bss部分的语法是
section .bss text section text部分用于保留实际代码。此section必须以全局声明_start开头，该声明告诉内核程序从何处开始执行。
section .text global _start _start: 注释 ; this is a comment  mov a, b ; move b to a statements [label] mnemonic [operands] [;comment] hello world示例 section	.text global _start ;must be declared for linker (ld) 	_start:	;tells linker entry point  mov	edx,len ;message length  mov	ecx,msg ;message to write  mov	ebx,1 ;file descriptor (stdout)  mov	eax,4 ;system call number (sys_write)  int	0x80 ;call kernel 	mov	eax,1 ;system call number (sys_exit)  int	0x80 ;call kernel  section	.</description>
    </item>
    
    <item>
      <title>汇编语言之数学操作 Math Operations List</title>
      <link>https://realjf.io/assembly/math-operations-list/</link>
      <pubDate>Sat, 30 May 2020 22:23:28 +0800</pubDate>
      
      <guid>https://realjf.io/assembly/math-operations-list/</guid>
      <description></description>
    </item>
    
    <item>
      <title>汇编语言之跳转标识 Jump Symbol</title>
      <link>https://realjf.io/assembly/jump-symbol/</link>
      <pubDate>Sat, 30 May 2020 22:00:29 +0800</pubDate>
      
      <guid>https://realjf.io/assembly/jump-symbol/</guid>
      <description></description>
    </item>
    
    <item>
      <title>汇编语言之系统调用寄存器输入 System Call Inputs by Register</title>
      <link>https://realjf.io/assembly/system-call-inputs-by-register/</link>
      <pubDate>Sat, 30 May 2020 21:30:25 +0800</pubDate>
      
      <guid>https://realjf.io/assembly/system-call-inputs-by-register/</guid>
      <description>示例 </description>
    </item>
    
    <item>
      <title>汇编语言之寄存器 Registers</title>
      <link>https://realjf.io/assembly/registers/</link>
      <pubDate>Sat, 30 May 2020 21:28:19 +0800</pubDate>
      
      <guid>https://realjf.io/assembly/registers/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>