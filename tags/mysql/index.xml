<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>mysql on Realjf&#39;s blog</title>
    <link>https://realjf.io/tags/mysql/</link>
    <description>Recent content in mysql on Realjf&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 27 Feb 2023 21:59:05 +0800</lastBuildDate><atom:link href="https://realjf.io/tags/mysql/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Index Principle and Optimization 索引的原理和优化</title>
      <link>https://realjf.io/mysql/index-principle-and-optimization/</link>
      <pubDate>Mon, 27 Feb 2023 21:59:05 +0800</pubDate>
      
      <guid>https://realjf.io/mysql/index-principle-and-optimization/</guid>
      <description>在数据库查询出现性能瓶颈时，索引是提升查询性能的绝佳手段。它能轻松缩小一个数量级的查询时间。
索引的原理 索引常用的数据结构：
 哈希表 二叉树 多叉树 其他  哈希表索引 哈希表索引的索引存在一些局限性：
 只能进行“=” “IN” 和 “&amp;lt;=&amp;gt;” 这类等值查询，而不能进行区间查询，对于需要排序、比较、区间查找并不适合 哈希碰撞会降低系统的查询效率  BTree索引 利用B-树或者B+树来读数据表中的指定属性建立索引。
 B-树的所有节点都存储数据，B+树只在叶子节点存储数据 MyISAM、InnoDB等都使用B+树来实现索引  BTree数据是排序的，因此支持区间，比较等查询方式。
位图索引 属性的可选值是有限的。 位图索引基本原理是向量化和位逻辑运算
位图索引只适合建立在不常发生变动的属性上
索引分析 为了及时发现索引失效的情况，可以在检索SQL语句前增加EXPLAIN或者DESCRIBE关键字来分析索引的生效过程。
EXPLAIN给出结果各字段含义如下：
  id：此次查询到唯一性标识
  select_type：查询操作的类型，如不含UNION的简单查询操作、最外层的查询操作、子查询操作、UNION查询操作等
 simple：简单查询 primary：复杂查询中最外层的select subquery：子查询 derived：派生表、临时表 union union result    table：查询所涉及到表名称
  partitions：查询所涉及到表分区，如果表未分区，为null
  type：连接类型，这个字段十分重要，依次从最优到最差为：system，const，eq_ref，ref，fulltext，ref_or_null，unique_subquery，index_subquery，range，index_merge，index，ALL
 null:MySQL不用访问表或者索引，直接就能够得到结果 system：表中只有一行数据或者是空表，且只能用于myisam和memory表。如果是Innodb引擎表，type列在这个情况通常都是all或者index const：根据主键或者唯一二级索引列与常数进行等值匹配, 表最多有一个匹配行，该行在查询开始时读取。const表非常快，因为它们只读取一次。当根据主键索引一条记录时，便是const类型的查询 eq_ref：在关联查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的，则对该被驱动表的访问方法就是eq_ref（唯一索引扫描） ref：通过普通的二级索引列与常量进行等值匹配时来查询某个表（非唯一索引扫描） fulltext：连接使用全文索引执行的 ref_or_null：类似于ref，但是mysql会额外搜索包含空值的行 unique_subquery：用于where中的in形式子查询，子查询返回不重复值唯一值 index_subquery：用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重。 range：在一定范围内查询索引表（索引范围扫描） index_merge：表示查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取所个索引，性能可能大部分时间都不如range index：对索引表（聚簇索引、非聚簇索引都算）进行整体遍历，虽然用到了索引但效率仍然较低（索引全扫描） ALL：全表扫描，完全没有用到任何索引，效率最低的一种情况    possible_keys：该查询操作可能利用的索引</description>
    </item>
    
    <item>
      <title>B-树和B&#43;树探讨 B Tree and B&#43;tree</title>
      <link>https://realjf.io/mysql/b-tree-and-b&#43;tree/</link>
      <pubDate>Wed, 16 Jun 2021 11:20:30 +0800</pubDate>
      
      <guid>https://realjf.io/mysql/b-tree-and-b&#43;tree/</guid>
      <description></description>
    </item>
    
    <item>
      <title>使用数据库实现链表 Using Database to Realize Linkedlist</title>
      <link>https://realjf.io/mysql/using-database-to-realize-linkedlist/</link>
      <pubDate>Wed, 09 Dec 2020 16:03:48 +0800</pubDate>
      
      <guid>https://realjf.io/mysql/using-database-to-realize-linkedlist/</guid>
      <description>背景 今天遇到一个需求，在一个排队队列中，对第一个人员可以进行延后处理操作（实际是往后移动 4 位，到第 5 位），一开始想通过排序值 控制队列排序问题，但是容错性差，不能得到很好的效果，想来想去链表结构的特性对于插入删除 O(1)的性能，可以很好的解决我的问题， 所以决定通过数据库表设计来实现一个链表。
 数据库：mysql 程序语言：php  实现 表结构简化成只有 id 和 next 指针的设计，next 指向下一个成员的 id。最后一个成员的 next 指向 0。
表结构及数值如下：
   id next     1 3   2 1   3 4   4 5   5 6   6 0    整理成链表大致是这样的
2 --&amp;gt; 1 --&amp;gt; 3 --&amp;gt; 4 --&amp;gt; 5 --&amp;gt; 6 --&amp;gt; 0 最后的 0 代表链表结束。</description>
    </item>
    
    <item>
      <title>mysql Explain 详解</title>
      <link>https://realjf.io/mysql/explain-analysis/</link>
      <pubDate>Thu, 14 May 2020 09:10:02 +0800</pubDate>
      
      <guid>https://realjf.io/mysql/explain-analysis/</guid>
      <description>explain 输出列    列名 JSON 名 说明     id select_id The SELECT identifier   select_type None The SELECT type   table table_name The table for the output row   partitions partitions The matching partitions   type access_type The join type   possible_keys possible_keys The possible indexes to choose   key key The index actually chosen   key_len key_length The length of the chosen key   ref ref The columns compared to the index   rows rows Estimate of rows to be examined   filtered filtered Percentage of rows filtered by table condition   Extra None Additional information    id select 标识</description>
    </item>
    
    <item>
      <title>Mysql 5.7.27源码安装教程</title>
      <link>https://realjf.io/posts/mysql-5.7-installation/</link>
      <pubDate>Tue, 15 Oct 2019 09:11:41 +0800</pubDate>
      
      <guid>https://realjf.io/posts/mysql-5.7-installation/</guid>
      <description>准备  debian 9操作系统 mysql下载地址：https://downloads.mysql.com/archives/get/file/mysql-5.7.27.tar.gz boost下载地址：http://nchc.dl.sourceforge.net/project/boost/boost/1.59.0/boost_1_59_0.tar.gz  下载安装 1. 下载安装boost  wget http://nchc.dl.sourceforge.net/project/boost/boost/1.59.0/boost_1_59_0.tar.gz  tar zxvf boost_1_59_0.tar.gz mv boost_1_59_0 /usr/local/boost 2. 下载安装mysql # 安装依赖包 apt-get install libncurses-dev   # 创建mysql用户组和用户 groupadd mysql useradd mysql -s /sbin/nologin -M -g mysql  # 下载mysql wget https://downloads.mysql.com/archives/get/file/mysql-5.7.27.tar.gz  tar zxvf mysql-5.7.27.tar.gz cd mysql-5.7.27  # 创建必要的文件夹 mkdir /usr/local/mysql mkdir /usr/local/mysql/data # 数据库文件 mkdir /usr/local/mysql/tmp # sock文件 mkdir /usr/local/mysql/logs # 错误日志文件 mkdir /usr/local/mysql/binlog # binlog日志文件  # 编译mysql cmake .</description>
    </item>
    
    <item>
      <title>Mysql Community Server Installation(mysql 8.0.17 社区版本安装教程)</title>
      <link>https://realjf.io/posts/mysql-community-server-installation/</link>
      <pubDate>Mon, 14 Oct 2019 17:50:16 +0800</pubDate>
      
      <guid>https://realjf.io/posts/mysql-community-server-installation/</guid>
      <description>一、下载安装 下载地址：https://downloads.mysql.com/archives/community/
# 下载 wget https://downloads.mysql.com/archives/get/file/mysql-8.0.17-linux-glibc2.12-x86_64.tar.xz xz -d mysql-8.0.17-linux-glibc2.12-x86_64.tar.xz tar xvf mysql-8.0.17-linux-glibc2.12-x86_64.tar  # 移动到你需要安装的目录下 mv mysql-8.0.17-linux-glibc2.12-x86_64 /usr/local/mysql 二、配置 1. 在mysql根目录下创建一个新的data目录，用于存放数据 cd /usr/local/mysql mkdir data 2. 创建mysql用户组和mysql用户 groupadd mysql useradd -g mysql mysql 3. 改变mysql目录权限 chown -R mysql.mysql /usr/local/mysql/ 4. 初始化数据库 # 创建mysql_install_db安装文件 mkdir mysql_install_db chmod 777 ./mysql_install_db  # 初始化数据库 bin/mysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data  # 记录好自己的临时密码 5. mysql配置 cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld 修改my.cnf文件
vim /etc/my.cnf [mysqld]  basedir = /usr/local/mysql  datadir = /usr/local/mysql/data  socket = /usr/local/mysql/mysql.</description>
    </item>
    
  </channel>
</rss>
