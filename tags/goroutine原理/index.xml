<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>goroutine原理 on Realjf&#39;s blog</title>
    <link>https://realjf.io/tags/goroutine%E5%8E%9F%E7%90%86/</link>
    <description>Recent content in goroutine原理 on Realjf&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 19 Mar 2019 14:45:21 +0800</lastBuildDate><atom:link href="https://realjf.io/tags/goroutine%E5%8E%9F%E7%90%86/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Goroutine 运行原理</title>
      <link>https://realjf.io/golang/goroutine-principle/</link>
      <pubDate>Tue, 19 Mar 2019 14:45:21 +0800</pubDate>
      
      <guid>https://realjf.io/golang/goroutine-principle/</guid>
      <description>Golang最大的特色可以说是协程(goroutine)了, 协程让本来很复杂的异步编程变得简单, 让程序员不再需要面对回调地狱, 虽然现在引入了协程的语言越来越多, 但go中的协程仍然是实现的是最彻底的.
核心概念 要理解协程的实现，需要理解三个重要概念，P、G和M。
G（goroutine） G是goroutine的简写，goroutine可以解释为受管理的轻量级线程，goroutine使用go关键字创建。
main函数是一个主线程，也是一个goroutine。
goroutine的新建、休眠、回复、停止都受到go运行时的管理 goroutine执行异步操作时会进入休眠状态，待操作完成后在恢复，无需占用系统线程。 goroutine新建或恢复时会添加到运行队列，等待M取出并运行。 M（machine） M是machine的简写，表示系统线程
M可以运行两种代码：
go代码，即goroutine，M运行go代码需要一个P
原生代码，例如阻塞的syscall，M运行原生代码不需要P
M运行时，会从G可运行队列中取出一个然后运行，如果G运行完毕或者进入休眠状态，则从可运行队列中取下一个G运行，周而复始。
有时候G需要调用一些无法避免阻塞的原生代码，这时M会释放持有的P并进入阻塞状态。其他M会取得这个P并继续运行队列中的G。
go需要保证有足够的M可以运行G，不让CPU闲着，也需要保证M的数量不过多。
P（process） P是process的简写，代表M运行G所需要的资源。
虽然P的数量默认等于cpu的核心数，但可以通过环境变量 GOMAXPROC 修改，在实际运行时P跟cpu核心并无任何关联。
P也可以理解为控制go代码的并行度的机制
如果P的数量等于1，代表当前最多只能有一个线程M执行go代码。 如果P的数量等于2，代表当前最多只能有两个线程M执行go代码。 执行原生代码的线程数不受P控制。
因为同一时间只有一个线程M可以拥有P，P中的数据都是锁自由的，读写这些数据的效率会非常的高。
数据结构 G的状态 空闲中(_Gidle)：表示G刚刚新建，仍未初始化 待运行(_Grunnable)：表示G在运行队列中，等待M取出并运行 运行中(_Grunning)：表示M正在运行这个G，这时候M会拥有一个P 系统调用中(_Gsyscall)：表示M正在运行这个G发起的系统调用，这时候M并不拥有P 等待中(_Gwaiting)：表示G在等待某些条件完成，这时候G不在运行也不在运行队列中（可能在channel的等待队列中） 已终止(_Gdead)：表示G未被使用，可能已执行完毕（并在freelist中等待下次复用） 栈复制中(_Gcopystack)：表示G正在获取一个新的栈空间并把原来的内容复制过去（用于防止GC扫描） M的状态 M并没有像G和P一样的状态标记，但可以认为一个M有以下的状态：
自旋中(spinning)：M正在从运行队列获取G，这时候M会拥有一个P 执行go代码中：M正在执行go代码，这时候M会拥有一个P 执行原生代码中：M正在执行原生代码或者阻塞的syscall，这时M并不拥有P 休眠中：M发现没有待运行的G时会进入休眠，并添加到空闲M链表中，这时M并不拥有P 自旋中这个状态非常重要，是否需要唤醒或者创建新的M取决于当前自旋中的M的数量。
P的状态 空闲中(_Pidle)：当M发现无待运行的G时会进入休眠，这时M拥有的P会变成空闲并加到空闲P链表中 运行中(_Prunning)：当M拥有了一个P后，这个P的状态就会变为运行中，M运行G会使用这个P中的资源。 系统调用中(_Psyscall)：当go调用原生代码，原生代码又反过来调用go代码时，使用的P会变成此状态 GC停止中(_Pgcstop)：当gc停止整个世界(STW)时，P会变为此状态。 已终止(_Pdead)：当P的数量在运行时改变，且数量减少时多余的P会变为此状态。 本地可运行队列G 在go中有多个运行队列可以保存待运行(_Grunnable)的G，他们分别是各个P中的本地运行队列和全局运行队列。
入队待运行的G时会优先加到当前P的本地运行队列，M获取待运行的G时也会优先从拥有的P的本地运行队列获取。
本地运行队列有数量限制，当数量达到256个时会入队到全局运行队列 本地运行队列的数据结构是环形队列，由一个256长度的数组和两个序号(head,tail)组成 当M从P的本地运行队列获取G时，如果发现本地队列为空会尝试从其他P盗取一半的G过来，这个机制叫做work stealing
全局可运行队列G 全局运行队列保存在全局变量sched中，全局运行队列入队和出队需要使用线程锁。
全局运行队列的数据结构是双向链表，由两个指针(head, tail)组成。
空闲M链表 当M发现无待运行的G时会进入休眠，并添加到空闲M链表中，空闲M链表保存在全局变量sched。 进入休眠的M会等待一个信号量(m.park)，唤醒休眠的M会使用这个信号量
go需要保证充足的M可以运行G，是通过以下机制实现的：
入队运行的G后，如果当前无自旋的M但是有空闲的P，就唤醒或者新建一个M。 当M离开自旋状态并准备运行出队的G时，如果当前无自旋的M但是有空闲的P，就唤醒或者新建一个M 当M离开自旋状态并准备休眠时，会在离开自旋状态后再次检查所有运行队列，如果有待运行的G则重新进入自旋状态。 因为“入队待运行的G”和“M离开自旋状态”会同时进行，go会使用这样的检查顺序：</description>
    </item>
    
  </channel>
</rss>
