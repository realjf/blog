<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>内存模型 on Realjf&#39;s blog</title>
    <link>https://realjf.io/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link>
    <description>Recent content in 内存模型 on Realjf&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 27 Apr 2020 16:44:23 +0800</lastBuildDate><atom:link href="https://realjf.io/tags/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C&#43;&#43;之内存模型 Memory Model</title>
      <link>https://realjf.io/cpp/memory-model/</link>
      <pubDate>Mon, 27 Apr 2020 16:44:23 +0800</pubDate>
      
      <guid>https://realjf.io/cpp/memory-model/</guid>
      <description>C++使用三种不同方案（C++11是四种）来存储数据：
 自动存储持续性 在函数定义中声明的变量（包括函数参数）的持续性为自动的。他们在程序开始执行其所属的函数或代码块时被创建，在执行完函数或代码块时，他们使用的内存将被释放。 静态存储持续性 在函数定义外定义的变量和使用关键字static定义的变量存储的持续性都为静态，他们在程序整个运行过程中都存在。 线程储存持续性（C++11）多核处理器很常见，如果变量是使用关键字thread_local声明的，则其生命周期与所属的线程一样长。 动态存储持续性 用new运算符分配的内存将一直存在，知道使用delete运算符将其释放或程序结束位置。这种内存的存储持续性为动态，有时被称为自由存储或堆   作用域描述了名称在文件的多大范围可见 链接性描述了名称如何在不同单元间共享。链接性为外部的名称可在文件间共享，链接性为内存的名称只能由一个文件中的函数共享。自动变量的名称没有链接性，因为它们不能共享。
 自动存储持续性 在默认情况下，在函数中声明的函数参数和变量的存储持续性为自动，作用域为局部，没有链接性。
自动变量和栈 由于自动变量的数目随函数的开始和结束而增减，因此程序常留出一段内存对自动变量进行管理，通常将其视为栈。
栈是后进先出的，这种设计简化了参数传递。函数调用将其参数的值放在栈顶，然后重新设置栈顶指针，被调用的函数根据其形参描述来确定每个参数的地址。
静态持续变量 c++为静态存储持续性变量提供了3种链接性：
 外部链接性（可在其他文件中访问）、 内部链接性（只能在当前文件中访问） 无连接性（只能在当前函数或代码中访问）  这三种链接性都在整个程序执行期间存在。
编译器将分配固定的内存块来存储所有的静态变量。主要是.data段里
 如果没有显示地初始化静态变量，编译器将把它设置为0.
    存储描述 持续性 作用域 链接性 如何声明     自动 自动 代码块 无 在代码块中   寄存器 自动 代码块 无 在代码块中，使用关键字register   静态，无链接性 静态 代码块 无 在代码块中，使用关键字static   静态，外部链接性 静态 文件 外部 不在任何函数内   静态，内部链接性 静态 文件 内部 不在任何函数内，使用关键字static    静态持续性、外部链接性 外部变量的存储持续性为静态，作用域为整个文件。外部变量也称全局变量。</description>
    </item>
    
  </channel>
</rss>
