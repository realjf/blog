<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>concurrency on Real_JF&#39;s blog</title>
    <link>https://realjf.io/tags/concurrency/</link>
    <description>Recent content in concurrency on Real_JF&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 21 Nov 2019 17:10:37 +0800</lastBuildDate>
    
	<atom:link href="https://realjf.io/tags/concurrency/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Golang 并发编程 之 runtime.LockOSThread</title>
      <link>https://realjf.io/posts/golang-concurrency-lockosthread/</link>
      <pubDate>Thu, 21 Nov 2019 17:10:37 +0800</pubDate>
      
      <guid>https://realjf.io/posts/golang-concurrency-lockosthread/</guid>
      <description>背景介绍 一些库（尤其是图形框架和库（例如Cocoa，OpenGL和libSDL））使用线程局部状态，并且可能要求仅从特定OS线程（通常是“主”线程）调用函数。 Go为此提供了runtime.LockOSThread函数，接下来通过示例说明如何正确使用它。
package dl import ( &amp;quot;fmt&amp;quot; &amp;quot;runtime&amp;quot; ) // 安排main.main在主线程上运行 func init() { runtime.LockOSThread() } // 在主线程main.main中调用Main循环 func Main() { for f := range mainfunc { // 取出工作队列中的函数进行调用 f() } } var mainfunc = make(chan func()) func do(f func()) { done := make(chan bool, 1) // 将整个函数加入到工作队列中 mainfunc &amp;lt;- func() { f() fmt.Println(&amp;quot;add queue&amp;quot;) done &amp;lt;- true } &amp;lt;-done } func Beep() { do(func() { // 无论什么时候都运行在主线程 fmt.</description>
    </item>
    
    <item>
      <title>Golang 并发编程 之 超时处理</title>
      <link>https://realjf.io/posts/golang-concurrency-timeout/</link>
      <pubDate>Thu, 21 Nov 2019 17:10:13 +0800</pubDate>
      
      <guid>https://realjf.io/posts/golang-concurrency-timeout/</guid>
      <description>并发编程中的超时处理 在并发编程中，要放弃运行时间太长的同步调用，请使用带有time.After的select语句，如下：
import ( &amp;quot;errors&amp;quot; &amp;quot;fmt&amp;quot; &amp;quot;time&amp;quot; ) func main() { var timeoutNanoseconds time.Duration = 5 * time.Second c := make(chan error, 1) go func() { time.Sleep(20 * time.Second) c &amp;lt;- errors.New(&amp;quot;error&amp;quot;) } () select { case err := &amp;lt;-c: // use err and reply fmt.Println(err) case &amp;lt;-time.After(timeoutNanoseconds): // call timed out fmt.Println(&amp;quot;timeout...&amp;quot;) } }  以上代码在超时5秒后退出</description>
    </item>
    
    <item>
      <title>Golang 并发编程 之 数据竞态检测</title>
      <link>https://realjf.io/posts/golang-data-race-detector/</link>
      <pubDate>Thu, 21 Nov 2019 16:41:31 +0800</pubDate>
      
      <guid>https://realjf.io/posts/golang-data-race-detector/</guid>
      <description>什么是数据争用或竞态 数据争用是并发系统中最常见且最难调试的错误类型之一。当两个goroutine并发访问同一变量并且至少其中之一是写操作时，就会发生数据争用。
下面让我们来实际模拟一下数据争用问题。
以下示例可能导致内存崩溃和损坏的数据争用
func main() { c := make(chan bool) m := make(map[string]string) go func() { m[&amp;quot;1&amp;quot;] = &amp;quot;a&amp;quot; c &amp;lt;- true }() m[&amp;quot;2&amp;quot;] = &amp;quot;b&amp;quot; &amp;lt;-c for k, v := range m { fmt.Println(k, v) } }  运行go run -race main.go进行竞争检测，得到的结果如下：
#================== WARNING: DATA RACE Write at 0x00c00008e150 by goroutine 6: runtime.mapassign_faststr() /usr/local/go/src/runtime/map_faststr.go:202 +0x0 main.main.func1() /root/go_project/src/test/race.go:9 +0x5d Previous write at 0x00c00008e150 by main goroutine: runtime.mapassign_faststr() /usr/local/go/src/runtime/map_faststr.go:202 +0x0 main.</description>
    </item>
    
  </channel>
</rss>