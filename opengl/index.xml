<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Opengls on Realjf&#39;s blog</title>
    <link>https://realjf.io/opengl/</link>
    <description>Recent content in Opengls on Realjf&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 10 May 2021 08:53:34 +0800</lastBuildDate>
    
	<atom:link href="https://realjf.io/opengl/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>opengl之三顶点属性与索引缓冲对象 Vertex Attribute and Element Buffer Object</title>
      <link>https://realjf.io/opengl/vertex-attribute-and-element-buffer-object/</link>
      <pubDate>Mon, 10 May 2021 08:53:34 +0800</pubDate>
      
      <guid>https://realjf.io/opengl/vertex-attribute-and-element-buffer-object/</guid>
      <description>顶点属性 顶点着色器允许指定任何以顶点属性为形式的输入。 所以，必须在渲染前指定OpenGL该如何解释顶点数据。
顶点缓冲对象（Vertex Buffer Object, VBO）:
 位置数据被存储为32位（4字节）浮点值 每个位置包含3个这样的值 在这三个值之间没有空隙，这几个值在数组中紧密排列 数据中第一个值在缓冲开始的位置  有了这些信息，可以使用glVertexAttribPointer函数告诉opengl该如何解析顶点数据：
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);   第一个参数指定要配置的顶点属性。顶点着色器使用layout(location=0)定义了position顶点属性的位置值，它可以把顶点属性值设置为0，因此这里用0传入。 第二个参数指定顶点属性的大小。顶点属性是一个vec3，它由三个值组成，所以大小是3。 第三个参数指定数据的类型，这里是GL_FLOAT(GLSL中vec*都是由浮点数值组成的) 第四个参数定义是否希望数据被标准化，如果设置为GL_TRUE，所有数据都会被映射到0到1之间，这里设置为GL_FALSE。 第五个参数定义步长（Stride），指定在连续的顶点属性组之间的间隔。由于下一组位置数据在3个float之后，所以设置步长为3*sizeof(float)，需注意数组是紧密排列的，也可以设置0让opengl决定具体步长是多少。 最后一个参数类型是void*，需进行强制类型转换，表示位置数据在缓冲中起始位置的偏移量（offset）。由于位置数据在数组的开头，所以这里是0.  每个顶点属性从一个VBO管理的内存中获得它的数据，而具体是从哪个VBO（程序中可以有多个VBO）获取则是通过在调用glVertexAttribPointer时绑定到GL_ARRAY_BUFFER的VBO决定的。由于在调用glVertexAttribPointer之前绑定的是先前定义的VBO对象，顶点属性0现在会链接到它的顶点数据。
glEnableVertexAttribArray(0);  使用glEnableVertexAttribArray启用顶点属性，以顶点属性位置值作为参数启用顶点属性，默认是禁用的。
完整的代码如下：
// 0. 复制顶点数组到缓冲中供OpenGL使用 glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); // 1. 设置顶点属性指针 glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); // 2. 当渲染一个物体时要使用着色器程序 glUseProgram(shaderProgram); // 3. 绘制物体 ...  顶点数组对象 顶点数组对象(Vertex Array Object, VAO)，可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个VAO中。这样的好处就是，当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的VAO就行了。</description>
    </item>
    
    <item>
      <title>opengl之二使用Opengl画一个三角形快速开始 Draw Triangles Quick Start</title>
      <link>https://realjf.io/opengl/draw-triangles-quick-start/</link>
      <pubDate>Sat, 08 May 2021 16:04:07 +0800</pubDate>
      
      <guid>https://realjf.io/opengl/draw-triangles-quick-start/</guid>
      <description>在上一篇 opengl 快速开始 的基础上，我们画一个三角形，并着色。
opengl渲染过程 了解三种缓冲对象  顶点数组对象：Vertex Array Object，VAO 顶点缓冲对象：Vertex Buffer Object，VBO 索引缓冲对象：Element Buffer Object，EBO或Index Buffer Object，IBO  图形渲染管线 图形渲染管线实际上是一堆原始图形数据途径一个输送管道，期间经过各种变化处理最终出现在屏幕的过程。
图形渲染管线分为两部分：
 第一部分把你的3d坐标转换为2d坐标 第二部分把2d坐标转变为实际的有颜色的像素   2D坐标和像素也是不同的，2D坐标精确表示一个点在2D空间中的位置，而2D像素是这个点的近似值，2D像素受到你的屏幕/窗口分辨率的限制。
 着色器 图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。 GPU为每个（渲染管线）阶段运行各自的小程序，这个小程序叫做着色器。opengl着色器用opengl着色器语言（OpenGL Shading Language, GLSL）写成。
渲染过程各个阶段  要注意蓝色部分代表的是我们可以注入自定义的着色器的部分
 顶点数据 首先用包含3个3d坐标的数组作为数据输入，这个数组叫顶点数据（Vertex Data），顶点数据使用顶点属性表示的。
顶点着色器 顶点着色器主要的目的是把3D坐标转为另一种3D坐标，同时顶点着色器允许我们对顶点属性进行一些基本处理。
图元装配 图元装配(Primitive Assembly)阶段将顶点着色器输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并所有的点装配成指定图元的形状；
几何着色器 几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状
光栅化阶段 这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率
片段着色器 主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色。
alpha测试和混合阶段 这个阶段检测片段的对应的深度（和模板(Stencil)）值，用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查alpha值（alpha值定义了一个物体的透明度）并对物体进行混合(Blend)。
准备 main.cpp原始内容如下：
#include &amp;lt;glad/glad.h&amp;gt; #include &amp;lt;GLFW/glfw3.h&amp;gt; #include &amp;lt;iostream&amp;gt; void framebuffer_size_callback(GLFWwindow* window, int width, int height); void processInput(GLFWwindow *window); const unsigned int SCR_WIDTH = 800; const unsigned int SCR_HEIGHT = 600; int main() { glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // create window GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, &amp;quot;LearnOpenGL&amp;quot;, NULL, NULL); if (window == NULL) { std::cout &amp;lt;&amp;lt; &amp;quot;Failed to create GLFW window&amp;quot; &amp;lt;&amp;lt; std::endl; glfwTerminate(); return -1; } glfwMakeContextCurrent(window); // viewport size glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); // init glad if(!</description>
    </item>
    
    <item>
      <title>opengl之一快速开始 Opengl Quick Start</title>
      <link>https://realjf.io/opengl/opengl-quick-start/</link>
      <pubDate>Fri, 07 May 2021 19:45:37 +0800</pubDate>
      
      <guid>https://realjf.io/opengl/opengl-quick-start/</guid>
      <description>准备  Ubuntu OS v20.04 glfw v3.3.4 glad  gl v4.6 core  cmake v3.18.4  目录结构 . ├── CMakeLists.txt ├── deps │ ├── glad │ │ ├── include │ │ │ ├── glad │ │ │ │ └── glad.h │ │ │ └── KHR │ │ │ └── khrplatform.h │ │ └── src │ │ └── glad.c │ └── glfw ├── preinstall.sh ├── src │ ├── CMakeLists.txt │ ├── glad.</description>
    </item>
    
    <item>
      <title>如何从源码构建GLFW How to Compile Glfw From Source</title>
      <link>https://realjf.io/opengl/how-to-compile-glfw-from-source/</link>
      <pubDate>Sat, 23 Jan 2021 00:47:53 +0800</pubDate>
      
      <guid>https://realjf.io/opengl/how-to-compile-glfw-from-source/</guid>
      <description>首先glfw下载 https://www.glfw.org/download.html
下载源码包后，开始安装
 环境：debian-10  构建 unzip glfw-3.3.2.zip mkdir glfw-build cd glfw-build cmake ..  报错如下：
-- The C compiler identification is GNU 10.2.0 -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Check for working C compiler: /usr/bin/cc - skipped -- Detecting C compile features -- Detecting C compile features - done -- Looking for pthread.h -- Looking for pthread.h - found -- Performing Test CMAKE_HAVE_LIBC_PTHREAD -- Performing Test CMAKE_HAVE_LIBC_PTHREAD - Failed -- Looking for pthread_create in pthreads -- Looking for pthread_create in pthreads - not found -- Looking for pthread_create in pthread -- Looking for pthread_create in pthread - found -- Found Threads: TRUE -- Found Doxygen: /usr/bin/doxygen (found version &amp;quot;1.</description>
    </item>
    
  </channel>
</rss>