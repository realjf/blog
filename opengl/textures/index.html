<!doctype html>
<html>

<head>
    <title>opengl之五 纹理 Textures // Realjf&#39;s blog</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.101.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="realjf" />
    <meta name="description"
        content="" />
    <base href="https://realjf.io/" />
    <link rel="stylesheet" href="https://realjf.io/css/main.min.0b68cfbaea60634bb6fd6850a294eb3f8c1a7bd7ff87d5f83e496b6223fe53d8.css" />
    <link rel="icon" href="./favicon.ico" type="image/x-icon" />
    <link rel="shortcut icon" href="./favicon.ico" type="image/x-icon" />
    
    <script src="./js/highlight.pack.js"> </script>
    
    <link rel="stylesheet" href="./css/monokai-sublime.css">
    <script>hljs.initHighlightingOnLoad();</script>
</head>

<body>
    
    <header class="app-header">
        <a href="/"><img class="app-header-avatar" src="./avatar.jpg" /></a>
        <h1>Realjf&#39;s blog</h1>
        <p>认识自己，接受自己，忘记自己，追随自己的灵魂</p>
        <div class="app-header-social">
            
            <a target="_blank" href="https://github.com/realjf"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
            
            <a target="_blank" href="https://twitter.com/realjf2"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter">
  <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>
</svg></a>
            
        </div>
        <div>
            <script type="text/javascript" src="//rf.revolvermaps.com/0/0/6.js?i=56j9sfhb0ei&amp;m=7&amp;c=e63100&amp;cr1=ffffff&amp;f=arial&amp;l=0&amp;bv=90&amp;lx=-420&amp;ly=420&amp;hi=20&amp;he=7&amp;hc=a8ddff&amp;rs=80" async="async"></script>
        </div>
    </header>
    <main class="app-container">
        <nav class="sidebar-nav">
    
    
            <a class="sidebar-nav-item" href="/" title="首页"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-home">
  <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline>
</svg> 首页</a>
    
            <a class="sidebar-nav-item" href="/posts/" title="归档"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-archive">
  <polyline points="21 8 21 21 3 21 3 8"></polyline><rect x="1" y="3" width="22" height="5"></rect><line x1="10" y1="12" x2="14" y2="12"></line>
</svg> 归档</a>
    
            <a class="sidebar-nav-item" href="/tags/" title="标签"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line>
</svg> 标签</a>
    
            <a class="sidebar-nav-item" href="/categories/" title="分类"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-menu">
  <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line>
</svg> 分类</a>
    
</nav>
        <style>
    @media screen and (max-width: 500px) {
        .search{
             
            text-align: center;
        }

        .search input{
            width: 100%;
        }

        .search button{
             
        }
    }
     
    @media screen and (min-width: 320px) {
        .search{
            width: 100%;
            text-align: center;
        }

        .search input{
            width: 50%;
        }
    }

     
    .search{
        margin: auto;
    }

    .search input{
        outline: none;
        border: 2px solid #57cc8a;
        height: 40px;
    }
    .search .button {
        display: inline-block;
        position:relative;
    }
    .search .button button{
        outline: none;
        height: 40px;
        border: 0;
        width: 60px;
        background-color: #57A64A;
        margin: 0;
    }
    .search .icon{
        width: 22px;
        height: 22px;
    }
</style>
<div class="search">
    <input type="text" placeholder="search..." id="search-key" />
    <div class="button">
        <button onclick="search()">
            <svg t="1583982313567" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1271"
                 width="200" height="200" xmlns:xlink="http://www.w3.org/1999/xlink">
                <defs>
                    <style type="text/css"></style>
                </defs>
                <path d="M694.857143 475.428571q0-105.714286-75.142857-180.857142T438.857143 219.428571 258 294.571429 182.857143 475.428571t75.142857 180.857143T438.857143 731.428571t180.857143-75.142857T694.857143 475.428571z m292.571428 475.428572q0 29.714286-21.714285 51.428571t-51.428572 21.714286q-30.857143 0-51.428571-21.714286l-196-195.428571q-102.285714 70.857143-228 70.857143-81.714286 0-156.285714-31.714286t-128.571429-85.714286-85.714286-128.571428T36.571429 475.428571t31.714285-156.285714 85.714286-128.571428 128.571429-85.714286T438.857143 73.142857t156.285714 31.714286 128.571429 85.714286 85.714285 128.571428T841.142857 475.428571q0 125.714286-70.857143 228l196 196q21.142857 21.142857 21.142857 51.428572z"
                      p-id="1272" fill="#ffffff"></path>
            </svg>
        </button>
    </div>
</div>
<h1 id="search-tip" style="color: #57A64A;text-align: center;display: none;">搜索中，请稍后 ...</h1>
<br />
<div id="result"></div>

<script type="text/javascript">
    
    window.onload = function() {
        document.onkeydown = function(ev) {
            var event = ev || event
            if (event.keyCode === 13) {
                search()
            }
        }
    }

    
    function search() {
        var key = document.getElementById("search-key").value;
        if (key === "") {
            return;
        }
        

        
        document.getElementById("search-tip").innerText = "搜索中，请稍后 ...";
        document.getElementById("search-tip").style.display = "block";

        
        var el = document.getElementById('result');
        var childs = el.childNodes;
        for (var i = childs.length - 1; i >= 0; i--) {
            el.removeChild(childs[i]);
        }

        
        var xmltext = new XMLHttpRequest;
        xmltext.open("GET", "./index.xml", false);
        xmltext.send();
        var resp = xmltext.responseXML;
        var items = resp.getElementsByTagName("item");
        
        var i = 0;
        var haveResult = false;
        while (i < items.length) {
            var txt = items[i].getElementsByTagName("title")[0].innerHTML + items[i].getElementsByTagName("description")[0].innerHTML;
            var reg = new RegExp(key, "gi");
            if (txt.search(reg) > -1) {
                haveResult = true;
                var title = items[i].getElementsByTagName("title")[0].innerHTML;
                var link = items[i].getElementsByTagName("link")[0].innerHTML;
                var time = items[i].getElementsByTagName("pubDate")[0].innerHTML;
                var mark = items[i].getElementsByTagName("description")[0].innerHTML;
                addItem(title, link, time, mark)
            }
            i++;
        }
        if (!haveResult) {
            document.getElementById("search-tip").innerText = "搜索完毕，未发现结果 ...";
            document.getElementById("search-tip").style.display = "block";
        }
    }

    
    function addItem(title, link, time, mark) {
        document.getElementById("search-tip").style.display = "none";
        var tmpl = "<article class=\"post\" style=\"border-bottom: 1px solid #e6e6e6;\" >" +
            "<header class=\"post-header\">" +
            "<h1 class=\"post-title\"><a class=\"post-link\" href=\"" + link + "\" target=\"_blank\">" + title + "</a></h1>" +
            "<div class=\"post-meta\">" +
            " <span class=\"post-time\">" + time + "</span>" +
            "</div>" +
            " </header>" +
            "<div class=\"post-content\">" +
            "<div class=\"post-summary\">" + mark + "</div>" +
            "<div class=\"read-more\">" +
            "<a href=\"" + link + "\" class=\"read-more-link\" target=\"_blank\">阅读更多</a>" +
            "</div>" +
            " </div>" +
            "</article>"
        var div = document.createElement("div")
        div.innerHTML = tmpl;
        document.getElementById('result').appendChild(div)

    }
</script>
        
    <article class="post">
        <header class="post-header">
            <h1 class ="post-title">opengl之五 纹理 Textures</h1>
            <div class="post-meta">
                <div>
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
                    May 10, 2020
                </div>
                <div>
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
                    3 min read
                </div><div>
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tag">
  <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line>
</svg>
                        <a class="tag" href="https://realjf.io/tags/opengl/">opengl</a></div></div>
        </header>
        <div class="post-content">
            <h3 id="纹理">纹理</h3>
<p>纹理是一个2D图片（甚至也有1D和3D的纹理），它可以用来添加物体的细节；你可以想象纹理是一张绘有砖块的纸，无缝折叠贴合到你的3D的房子上，这样你的房子看起来就像有砖墙外表了。因为可以在一张图片上插入非常多的细节，这样就可以让物体非常精细而不用指定额外的顶点。</p>
<p>为了能够把纹理映射(Map)到三角形上，需要指定三角形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个纹理坐标(Texture Coordinate)，用来标明该从纹理图像的哪个部分采样。之后在图形的其它片段上进行片段插值(Fragment Interpolation)。</p>
<p>纹理坐标在x和y轴上，范围为0到1之间（注意使用的是2D纹理图像）。使用纹理坐标获取纹理颜色叫做采样(Sampling)。纹理坐标起始于(0, 0)，也就是纹理图片的左下角，终始于(1, 1)，即纹理图片的右上角。下面的图片展示了如何把纹理坐标映射到三角形上的。</p>
<p><img src="/image/tex_coords.png" alt="纹理坐标"></p>
<p>为三角形指定了3个纹理坐标点。如上图所示，三角形的左下角对应纹理的左下角，因此把三角形左下角顶点的纹理坐标设置为(0, 0)；三角形的上顶点对应于图片的上中位置所以把它的纹理坐标设置为(0.5, 1.0)；同理右下方的顶点设置为(1, 0)。只要给顶点着色器传递这三个纹理坐标就行了，接下来它们会被传片段着色器中，它会为每个片段进行纹理坐标的插值。</p>
<p>纹理坐标看起来像是这样的：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> texCoords[] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#ae81ff">0.0f</span>, <span style="color:#ae81ff">0.0f</span>, <span style="color:#75715e">// 左下角
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#ae81ff">1.0f</span>, <span style="color:#ae81ff">0.0f</span>, <span style="color:#75715e">// 右下角
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#ae81ff">0.5f</span>, <span style="color:#ae81ff">1.0f</span> <span style="color:#75715e">// 上中
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><h3 id="纹理环绕方式">纹理环绕方式</h3>
<p>纹理坐标的范围通常是从(0, 0)到(1, 1)，如果把纹理坐标设置在范围之外，OpenGL默认的行为是重复这个纹理图像（基本上忽略浮点纹理坐标的整数部分），但OpenGL提供了更多的选择：</p>
<table>
<thead>
<tr>
<th style="text-align:center">环绕方式</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">GL_REPEAT</td>
<td style="text-align:center">对纹理的默认行为，重复纹理图像</td>
</tr>
<tr>
<td style="text-align:center">GL_MIRRORED_REPEAT</td>
<td style="text-align:center">和GL_REPEAT一样，但每次重复图片是镜像放置的</td>
</tr>
<tr>
<td style="text-align:center">GL_CLAMP_TO_EDGE</td>
<td style="text-align:center">纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果</td>
</tr>
<tr>
<td style="text-align:center">GL_CLAMP_TO_BORDER</td>
<td style="text-align:center">超出的坐标为用户指定的边缘颜色</td>
</tr>
</tbody>
</table>
<p>当纹理超出范围时的效果：</p>
<p><img src="/image/texture_wrapping.png" alt="纹理效果"></p>
<p>前面提到的每个选项都可以使用glTexParameter*函数对单独的一个坐标轴设置（s、t如果是使用3D纹理那么还有一个r），他们和x、y、z是等价的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT);
</span></span><span style="display:flex;"><span>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);
</span></span></code></pre></div><ul>
<li>第一个参数指定了纹理目标；使用的是2D纹理，因此纹理目标是GL_TEXTURE_2D。</li>
<li>第二个参数需要指定设置的选项与应用的纹理轴。打算配置的是WRAP选项，并且指定S和T轴。</li>
<li>最后一个参数需要传递一个环绕方式(Wrapping)</li>
</ul>
<p>如果选择GL_CLAMP_TO_BORDER选项，还需要指定一个边缘的颜色。这需要使用glTexParameter函数的fv后缀形式，用GL_TEXTURE_BORDER_COLOR作为它的选项，并且传递一个float数组作为边缘的颜色值：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> borderColor[] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">1.0f</span>, <span style="color:#ae81ff">1.0f</span>, <span style="color:#ae81ff">0.0f</span>, <span style="color:#ae81ff">1.0f</span> };
</span></span><span style="display:flex;"><span>glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, borderColor);
</span></span></code></pre></div><h3 id="纹理过滤">纹理过滤</h3>
<p>纹理坐标不依赖于分辨率(Resolution)，它可以是任意浮点值，所以OpenGL需要知道怎样将纹理像素(Texture Pixel，也叫Texel，译注1)映射到纹理坐标。当你有一个很大的物体但是纹理的分辨率很低的时候这就变得很重要了。你可能已经猜到了，OpenGL也有对于纹理过滤(Texture Filtering)的选项。纹理过滤有很多个选项，但是现在只讨论最重要的两种：GL_NEAREST和GL_LINEAR。</p>
<p>GL_NEAREST（也叫邻近过滤，Nearest Neighbor Filtering）是OpenGL默认的纹理过滤方式。当设置为GL_NEAREST的时候，OpenGL会选择中心点最接近纹理坐标的那个像素。下图中你可以看到四个像素，加号代表纹理坐标。左上角那个纹理像素的中心距离纹理坐标最近，所以它会被选择为样本颜色</p>
<p><img src="/image/filter_nearest.png" alt="nearest"></p>
<p>GL_LINEAR（也叫线性过滤，(Bi)linear Filtering）它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。下图中你可以看到返回的颜色是邻近像素的混合色：</p>
<p><img src="/image/filter_linear.png" alt="linear"></p>
<p>那么这两种纹理过滤方式有怎样的视觉效果呢？让我们看看在一个很大的物体上应用一张低分辨率的纹理会发生什么吧（纹理被放大了，每个纹理像素都能看到）：</p>
<p><img src="/image/texture_filteriing.png" alt="纹理过滤效果"></p>
<p>GL_NEAREST产生了颗粒状的图案，能够清晰看到组成纹理的像素，而GL_LINEAR能够产生更平滑的图案，很难看出单个的纹理像素。GL_LINEAR可以产生更真实的输出，但有些开发者更喜欢8-bit风格，所以他们会用GL_NEAREST选项。</p>
<p>当进行放大(Magnify)和缩小(Minify)操作的时候可以设置纹理过滤的选项</p>
<p>使用glTexParameter*函数为放大和缩小指定过滤方式</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
</span></span><span style="display:flex;"><span>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
</span></span></code></pre></div><h4 id="多级渐远纹理">多级渐远纹理</h4>
<p>OpenGL使用一种叫做多级渐远纹理来处理远处的物体纹理。</p>
<p>简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一。多级渐远纹理背后的理念很简单：距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一加分之处是它的性能非常好。</p>
<p>手工为每个纹理图像创建一系列多级渐远纹理很麻烦，OpenGL有一个glGenerateMipmaps函数，在创建完一个纹理后调用它OpenGL就会承担接下来的所有工作了</p>
<p>切换多级渐远纹理级别时你也可以在两个不同多级渐远纹理级别之间使用NEAREST和LINEAR过滤。为了指定不同多级渐远纹理级别之间的过滤方式，你可以使用下面四个选项中的一个代替原有的过滤方式：</p>
<table>
<thead>
<tr>
<th style="text-align:center">过滤方式</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">GL_NEAREST_MIPMAP_NEAREST</td>
<td style="text-align:center">使用最邻近的多级渐远纹理来匹配像素大小，并使用邻近插值进行纹理采样</td>
</tr>
<tr>
<td style="text-align:center">GL_LINEAR_MIPMAP_NEAREST</td>
<td style="text-align:center">使用最邻近的多级渐远纹理级别，并使用线性插值进行采样</td>
</tr>
<tr>
<td style="text-align:center">GL_NEAREST_MIPMAP_LINEAR</td>
<td style="text-align:center">在两个最匹配像素大小的多级渐远纹理之间进行线性插值，使用邻近插值进行采样</td>
</tr>
<tr>
<td style="text-align:center">GL_LINEAR_MIPMAP_LINEAR</td>
<td style="text-align:center">在两个邻近的多级渐远纹理之间使用线性插值，并使用线性插值进行采样</td>
</tr>
</tbody>
</table>
<p>可以使用glTexParameteri将过滤方式设置为前面四种提到的方法之一：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
</span></span><span style="display:flex;"><span>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
</span></span></code></pre></div><p><strong>一个常见的错误是，将放大过滤的选项设置为多级渐远纹理过滤选项之一</strong>。
这样没有任何效果，因为多级渐远纹理主要是使用在纹理被缩小的情况下的：纹理放大不会使用多级渐远纹理，为放大过滤设置多级渐远纹理的选项会产生一个GL_INVALID_ENUM错误代码。</p>
<h3 id="加载与创建纹理">加载与创建纹理</h3>
<p>使用纹理之前要做的第一件事是把它们加载到应用中。纹理图像可能被储存为各种各样的格式，每种都有自己的数据结构和排列，使用一个支持多种流行格式的图像加载库来处理是一种很好的选择。</p>
<h4 id="stb_imageh">stb_image.h</h4>
<p>stb_image.h是<a href="https://github.com/nothings">Sean Barrett</a>的一个非常流行的单头文件图像加载库，它能够加载大部分流行的文件格式，并且能够很简单得整合到你的工程之中。stb_image.h可以在<a href="https://github.com/nothings/stb/blob/master/stb_image.h">这里</a>下载</p>
<p>一个新的C++文件，输入以下代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">#define STB_IMAGE_IMPLEMENTATION
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&#34;stb_image.h&#34;</span><span style="color:#75715e">
</span></span></span></code></pre></div><p>通过定义STB_IMAGE_IMPLEMENTATION，预处理器会修改头文件，让其只包含相关的函数定义源码，等于是将这个头文件变为一个 .cpp 文件了。现在只需要在你的程序中包含stb_image.h并编译就可以了。</p>
<p>要使用stb_image.h加载图片，需要使用它的stbi_load函数：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> width, height, nrChannels;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>data <span style="color:#f92672">=</span> stbi_load(<span style="color:#e6db74">&#34;container.jpg&#34;</span>, <span style="color:#f92672">&amp;</span>width, <span style="color:#f92672">&amp;</span>height, <span style="color:#f92672">&amp;</span>nrChannels, <span style="color:#ae81ff">0</span>);
</span></span></code></pre></div><ul>
<li>第一个参数是图像文件路径</li>
<li>第二个参数是图像宽度</li>
<li>第三个参数是图像高度</li>
<li>第四个参数是图像颜色通道的个数</li>
</ul>
<h3 id="生成纹理">生成纹理</h3>
<p>创建一个纹理</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> texture;
</span></span><span style="display:flex;"><span>glGenTextures(<span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>texture);
</span></span></code></pre></div><p>通过绑定，让之后任何的纹理指令都可以配置当前绑定的纹理：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glBindTexture(GL_TEXTURE_2D, texture);
</span></span></code></pre></div><p>使用glTexImage2D来载入图片生成一个纹理：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glTexImage2D(GL_TEXTURE_2D, <span style="color:#ae81ff">0</span>, GL_RGB, width, height, <span style="color:#ae81ff">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);
</span></span><span style="display:flex;"><span>glGenerateMipmap(GL_TEXTURE_2D);
</span></span></code></pre></div><ul>
<li>第一个参数指定了纹理目标(Target)。设置为GL_TEXTURE_2D意味着会生成与当前绑定的纹理对象在同一个目标上的纹理（任何绑定到GL_TEXTURE_1D和GL_TEXTURE_3D的纹理不会受到影响）。</li>
<li>第二个参数为纹理指定多级渐远纹理的级别，如果希望单独手动设置每个多级渐远纹理的级别的话。这里填0，也就是基本级别。</li>
<li>第三个参数告诉OpenGL把纹理储存为何种格式。我们的图像只有RGB值，因此也把纹理储存为RGB值。</li>
<li>第四个和第五个参数设置最终的纹理的宽度和高度。之前加载图像的时候储存了它们，所以使用对应的变量。</li>
<li>下个参数应该总是被设为0（历史遗留的问题）。</li>
<li>第七第八个参数定义了源图的格式和数据类型。使用RGB值加载这个图像，并把它们储存为char(byte)数组，将会传入对应值。</li>
<li>最后一个参数是真正的图像数据。</li>
</ul>
<p>当调用glTexImage2D时，当前绑定的纹理对象就会被附加上纹理图像。然而，目前只有基本级别(Base-level)的纹理图像被加载了，如果要使用多级渐远纹理，我们必须手动设置所有不同的图像（不断递增第二个参数）。或者，直接在生成纹理之后调用glGenerateMipmap。这会为当前绑定的纹理自动生成所有需要的多级渐远纹理。</p>
<p>生成了纹理和相应的多级渐远纹理后，释放图像的内存</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>stbi_image_free(data);
</span></span></code></pre></div><p>现在，生成纹理的代码过程如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> texture;
</span></span><span style="display:flex;"><span>glGenTextures(<span style="color:#ae81ff">1</span>, <span style="color:#f92672">&amp;</span>texture);
</span></span><span style="display:flex;"><span>glBindTexture(GL_TEXTURE_2D, texture);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 为当前绑定的纹理对象设置环绕、过滤方式
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);   
</span></span><span style="display:flex;"><span>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
</span></span><span style="display:flex;"><span>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
</span></span><span style="display:flex;"><span>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 加载并生成纹理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> width, height, nrChannels;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>data <span style="color:#f92672">=</span> stbi_load(<span style="color:#e6db74">&#34;container.jpg&#34;</span>, <span style="color:#f92672">&amp;</span>width, <span style="color:#f92672">&amp;</span>height, <span style="color:#f92672">&amp;</span>nrChannels, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (data)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    glTexImage2D(GL_TEXTURE_2D, <span style="color:#ae81ff">0</span>, GL_RGB, width, height, <span style="color:#ae81ff">0</span>, GL_RGB, GL_UNSIGNED_BYTE, data);
</span></span><span style="display:flex;"><span>    glGenerateMipmap(GL_TEXTURE_2D);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Failed to load texture&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>stbi_image_free(data);
</span></span></code></pre></div><h3 id="应用纹理">应用纹理</h3>
<p>需要告知OpenGL如何采样纹理，所以必须使用纹理坐标更新顶点数据：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> vertices[] <span style="color:#f92672">=</span> {
</span></span><span style="display:flex;"><span><span style="color:#75715e">//     ---- 位置 ----       ---- 颜色 ----     - 纹理坐标 -
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#ae81ff">0.5f</span>,  <span style="color:#ae81ff">0.5f</span>, <span style="color:#ae81ff">0.0f</span>,   <span style="color:#ae81ff">1.0f</span>, <span style="color:#ae81ff">0.0f</span>, <span style="color:#ae81ff">0.0f</span>,   <span style="color:#ae81ff">1.0f</span>, <span style="color:#ae81ff">1.0f</span>,   <span style="color:#75715e">// 右上
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>     <span style="color:#ae81ff">0.5f</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">0.5f</span>, <span style="color:#ae81ff">0.0f</span>,   <span style="color:#ae81ff">0.0f</span>, <span style="color:#ae81ff">1.0f</span>, <span style="color:#ae81ff">0.0f</span>,   <span style="color:#ae81ff">1.0f</span>, <span style="color:#ae81ff">0.0f</span>,   <span style="color:#75715e">// 右下
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">-</span><span style="color:#ae81ff">0.5f</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">0.5f</span>, <span style="color:#ae81ff">0.0f</span>,   <span style="color:#ae81ff">0.0f</span>, <span style="color:#ae81ff">0.0f</span>, <span style="color:#ae81ff">1.0f</span>,   <span style="color:#ae81ff">0.0f</span>, <span style="color:#ae81ff">0.0f</span>,   <span style="color:#75715e">// 左下
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#f92672">-</span><span style="color:#ae81ff">0.5f</span>,  <span style="color:#ae81ff">0.5f</span>, <span style="color:#ae81ff">0.0f</span>,   <span style="color:#ae81ff">1.0f</span>, <span style="color:#ae81ff">1.0f</span>, <span style="color:#ae81ff">0.0f</span>,   <span style="color:#ae81ff">0.0f</span>, <span style="color:#ae81ff">1.0f</span>    <span style="color:#75715e">// 左上
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><p>现在，必须告诉opengl新的顶点格式如何解析：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glVertexAttribPointer(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>, GL_FLOAT, GL_FALSE, <span style="color:#ae81ff">8</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">float</span>), (<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>)(<span style="color:#ae81ff">6</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">float</span>)));
</span></span><span style="display:flex;"><span>glEnableVertexAttribArray(<span style="color:#ae81ff">2</span>);
</span></span></code></pre></div><p>接着，调整顶点着色器使其能够接收顶点坐标为一个顶点属性，并把坐标传给片段着色器：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-glsl" data-lang="glsl"><span style="display:flex;"><span><span style="color:#75715e">#version 330 core</span>
</span></span><span style="display:flex;"><span>layout (location <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">vec3</span> aPos;
</span></span><span style="display:flex;"><span>layout (location <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>) <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">vec3</span> aColor;
</span></span><span style="display:flex;"><span>layout (location <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>) <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">vec2</span> aTexCoord;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">out</span> <span style="color:#66d9ef">vec3</span> ourColor;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">out</span> <span style="color:#66d9ef">vec2</span> TexCoord;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    gl_Position <span style="color:#f92672">=</span> <span style="color:#66d9ef">vec4</span>(aPos, <span style="color:#ae81ff">1.0</span>);
</span></span><span style="display:flex;"><span>    ourColor <span style="color:#f92672">=</span> aColor;
</span></span><span style="display:flex;"><span>    TexCoord <span style="color:#f92672">=</span> aTexCoord;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>片段着色器也应该能访问纹理对象，GLSL有一个供纹理对象使用的内建数据类型，叫做采样器(Sampler)，它以纹理类型作为后缀，比如sampler1D、sampler3D，或sampler2D。可以简单声明一个uniform sampler2D把一个纹理添加到片段着色器中，稍后会把纹理赋值给这个uniform。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-glsl" data-lang="glsl"><span style="display:flex;"><span><span style="color:#75715e">#version 330 core</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">out</span> <span style="color:#66d9ef">vec4</span> FragColor;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">in</span> <span style="color:#66d9ef">vec3</span> ourColor;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">in</span> <span style="color:#66d9ef">vec2</span> TexCoord;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">uniform</span> <span style="color:#66d9ef">sampler2D</span> ourTexture;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    FragColor <span style="color:#f92672">=</span> texture(ourTexture, TexCoord);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>使用内建的texture函数来采样纹理的颜色：</p>
<ul>
<li>第一个参数是纹理采样器</li>
<li>第二个参数是对应的纹理坐标</li>
</ul>
<p>这个片段着色器的输出就是纹理的（插值）纹理坐标上的(过滤后的)颜色。</p>
<p>现在只剩下在调用glDrawElements之前绑定纹理了，它会自动把纹理赋值给片段着色器的采样器</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glBindTexture(GL_TEXTURE_2D, texture);
</span></span><span style="display:flex;"><span>glBindVertexArray(VAO);
</span></span><span style="display:flex;"><span>glDrawElements(GL_TRIANGLES, <span style="color:#ae81ff">6</span>, GL_UNSIGNED_INT, <span style="color:#ae81ff">0</span>);
</span></span></code></pre></div><h3 id="纹理单元">纹理单元</h3>
<p>使用glUniform1i，可以给纹理采样器分配一个位置值，这样的话能够在一个片段着色器中设置多个纹理。一个纹理的位置值通常称为一个纹理单元(Texture Unit)。一个纹理的默认纹理单元是0，它是默认的激活纹理单元，所以上述没有分配一个位置值。</p>
<p>纹理单元的主要目的是在着色器中可以使用多于一个的纹理。通过把纹理单元赋值给采样器，可以一次绑定多个纹理，只要首先激活对应的纹理单元。
可以使用glActiveTexture激活纹理单元，传入需要使用的纹理单元：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>glActiveTexture(GL_TEXTURE0); <span style="color:#75715e">// 在绑定纹理之前先激活纹理单元
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>glBindTexture(GL_TEXTURE_2D, texture);
</span></span></code></pre></div><p>激活纹理单元之后，接下来的glBindTexture函数调用会绑定这个纹理到当前激活的纹理单元，纹理单元GL_TEXTURE0默认总是被激活，所以在前面的例子里当使用glBindTexture的时候，无需激活任何纹理单元。</p>
<blockquote>
<p>OpenGL至少保证有16个纹理单元供你使用，也就是说你可以激活从GL_TEXTURE0到GL_TEXTRUE15。它们都是按顺序定义的，所以也可以通过GL_TEXTURE0 + 8的方式获得GL_TEXTURE8，这在当需要循环一些纹理单元的时候会很有用。</p>
</blockquote>
<p>现在需要修改下片段着色器来接收另一个采样器：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-glsl" data-lang="glsl"><span style="display:flex;"><span><span style="color:#75715e">#version 330 core</span>
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">uniform</span> <span style="color:#66d9ef">sampler2D</span> texture1;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">uniform</span> <span style="color:#66d9ef">sampler2D</span> texture2;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">void</span> main()
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    FragColor <span style="color:#f92672">=</span> mix(texture(texture1, TexCoord), texture(texture2, TexCoord), <span style="color:#ae81ff">0.2</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>最终输出颜色现在是两个纹理的结合。</p>
<p>mix函数接收三个参数：</p>
<ul>
<li>第一、第二个参数会根据第三个参数进行线性插值</li>
<li>第三个参数值为0.0，则返回第一个输入值</li>
<li>第三个参数值为1.0，则返回第二个输入值</li>
</ul>
<p>为了使用第二个纹理（以及第一个），必须改变一点渲染流程，先绑定两个纹理到对应的纹理单元，然后定义哪个uniform采样器对应哪个纹理单元：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">// 第一个纹理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>glActiveTexture(GL_TEXTURE0);
</span></span><span style="display:flex;"><span>glBindTexture(GL_TEXTURE_2D, texture1);
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 第二个纹理
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>glActiveTexture(GL_TEXTURE1);
</span></span><span style="display:flex;"><span>glBindTexture(GL_TEXTURE_2D, texture2);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>glBindVertexArray(VAO);
</span></span><span style="display:flex;"><span>glDrawElements(GL_TRIANGLES, <span style="color:#ae81ff">6</span>, GL_UNSIGNED_INT, <span style="color:#ae81ff">0</span>);
</span></span></code></pre></div><p>还要通过使用glUniform1i设置每个采样器的方式告诉OpenGL每个着色器采样器属于哪个纹理单元。只需要设置一次即可，所以这个会放在渲染循环的前面：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>ourShader.use(); <span style="color:#75715e">// 不要忘记在设置uniform变量之前激活着色器程序！
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>glUniform1i(glGetUniformLocation(ourShader.ID, <span style="color:#e6db74">&#34;texture1&#34;</span>), <span style="color:#ae81ff">0</span>); <span style="color:#75715e">// 手动设置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>ourShader.setInt(<span style="color:#e6db74">&#34;texture2&#34;</span>, <span style="color:#ae81ff">1</span>); <span style="color:#75715e">// 或者使用着色器类设置
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span>(...) 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    [...]
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>stb_image.h能够在图像加载时帮助翻转y轴，只需要在加载任何图像前加入以下语句即可</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>stbi_set_flip_vertically_on_load(true);
</span></span></code></pre></div><h3 id="完整代码">完整代码：</h3>
<p><a href="https://github.com/realjf/opengl/tree/master/src/getting-started/recipe-05">github.com/realjf/opengl/src/getting-started/recipe-05</a></p>

        </div>
        <div id="disqus_thread"></div>
<script>

    

    

    (function() { 
        var d = document, s = d.createElement('script');
        s.src = 'https://realjf.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </article>
    

    <div class="article-related">
        <hr/>
        <fieldset>
            <legend>相关阅读推荐（See Also）</legend>
            <ul>
                
                    <li><a href="/opengl/shader-and-uniform/">opengl之四 着色器和uniform Shader and Uniform</a></li>
                
                    <li><a href="/opengl/vertex-attribute-and-element-buffer-object/">opengl之三 顶点属性与索引缓冲对象 Vertex Attribute and Element Buffer Object</a></li>
                
                    <li><a href="/opengl/draw-triangles-quick-start/">opengl之二 使用Opengl画一个三角形快速开始 Draw Triangles Quick Start</a></li>
                
                    <li><a href="/opengl/opengl-quick-start/">opengl之一 快速开始 Opengl Quick Start</a></li>
                
                    <li><a href="/opengl/how-to-compile-glfw-from-source/">如何从源码构建GLFW How to Compile Glfw From Source</a></li>
                
            </ul>
        </fieldset>
    </div>


    
<aside class="aside-menu">
    <div class="aside-bar-icon">
        <i class="fa fa-list-alt"></i>
    </div>
    <ul>
        
        
            
                <li>
                    <a href="/" title="首页">
                        
                        <span>首页</span>
                    </a>
                </li>
            
        
            
                <li>
                    <a href="/posts/" title="归档">
                        
                        <span>归档</span>
                    </a>
                </li>
            
        
            
                <li>
                    <a href="/tags/" title="标签">
                        
                        <span>标签</span>
                    </a>
                </li>
            
        
            
                <li>
                    <a href="/categories/" title="分类">
                        
                        <span>分类</span>
                    </a>
                </li>
            
        
    </ul>
</aside>

    

    </main>
    <aside class="sider">
    <div>
        <h2>书籍</h2>
    </div>
    <ul>
        <li>
            <a href="https://premake.realjf.io" title="premake" target="_blank">
                <span>premake 中文手册</span>
            </a>
        </li>
        <li>
            <a href="https://gltf.realjf.io" title="glTF" target="_blank">
                <span>glTF 中文手册</span>
            </a>
        </li>
        <li>
            <a href="https://box2d.realjf.io" title="Box2D" target="_blank">
                <span>Box2D 中文手册</span>
            </a>
        </li>
        <li>
            <a href="https://gdb.realjf.io" title="gdb" target="_blank">
                <span>gdb 中文手册</span>
            </a>
        </li>
    </ul>
</aside>

    <div class="app-footer">
        <span>
  powered by <a target="_blank" href="https://gohugo.io">hugo</a> &nbsp;&nbsp;&nbsp;
   &copy; 2019 - 2021 <a href="https://realjf.io">realjf.io</a>
</span>
    </div>
    <script id="dsq-count-scr" src="//realjf.disqus.com/count.js" async></script>
    <script type="text/javascript" src="./js/highlight.min.js"></script>
</body>

</html>