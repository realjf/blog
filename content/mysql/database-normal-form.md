---
title: "数据库范式 Database Normal Form"
date: 2020-04-28T14:39:03+08:00
keywords: ["sql"]
categories: ["mysql"]
tags: ["sql"]
series: [""]
draft: false
toc: false
related:
  threshold: 80
  includeNewer: false
  toLower: false
  indices:
  - name: keywords
    weight: 100
  - name: tags
    weight: 90
  - name: categories
    weight: 50
  - name: date
    weight: 10
---

- 第一范式：关系模式中，每个属性不可再分。属性原子性
- 第二范式：非主属性完全依赖于主属性，即消除非主属性对主属性的部分函数依赖关系。
- 第三范式：非主属性对主属性不存在传递函数依赖关系。
- BNCF范式：在第三范式的基础上，消除主属性之间的部分函数依赖


### 第一范式（1NF）：在关系模式R中的每一个具体关系r中，如果每个属性值都是不可再分的最小数据单位，则称R是第一范式的关系。
例：如职工号，姓名，电话号码组成一个表（一个人可能有多个电话号码） 规范成为1NF有三种方法： 
　　一是重复存储职工号和姓名。这样，关键字只能是电话号码。 
　　二是职工号为关键字，电话号码分为单位电话和住宅电话两个属性 
　　三是职工号为关键字，但强制每条记录只能有一个电话号码。 

以上三个方法，第一种方法最不可取，按实际情况选取后两种情况。
 
### 第二范式（2NF）：如果关系模式R（U，F）中的所有非主属性都完全依赖于任意候选关键字，则称关系R 是属于第二范式的。 
例：选课关系 sc（sid，cid，grade，credit）其中sid为学号， cid为课程号，grade为成绩，credit为学分。 由以上条件，关键字为组合关键字（sid，cid） 
在应用中使用以上关系模式有以下问题： 
　　a.数据冗余，假设同一门课由40个学生选修，学分就重复40次。 
　　b.更新异常，若调整了某课程的学分，相应的元组credit值都要更新，有可能会出现同一门课学分不同。 
　　c.插入异常，如计划开新课，由于没人选修，没有学号关键字，只能等有人选修才能把课程和学分存入。 
　　d.删除异常，若学生已经结业，从当前数据库删除选修记录。某些门课程新生尚未选修，则此门课程及学分记录无法保存。 
原因：非关键字属性credit仅函数依赖于cid，也就是credit部分依赖组合关键字（sid，cid）而不是完全依赖。 
解决方法：分成两个关系模式sc（sid，cid，grade），c（cid，credit）。新关系包括两个关系模式，它们之间通过sc中的外关键字cid相联系，需要时再进行自然联接，恢复了原来的关系
 
### 第三范式（3NF）：如果关系模式R（U，F）中的所有非主属性对任何候选关键字都不存在传递依赖，则称关系R是属于第三范式的。 
例：如s（sid，sname，did，dname，location） 各属性分别代表学号，姓名，所在系，系名称，系地址。 
　　关键字sid决定各个属性。由于是单个关键字，没有部分依赖的问题，肯定是2NF。但这关系肯定有大量的冗余，有关学生所在的几个属性did，dname，location将重复存储，插入，删除和修改时也将产生类似以上例的情况。 
　　原因：关系中存在传递依赖造成的。即sid -> did。 而did ->sid却不存在，did -> location, 因此关键字sid对location函数决定是通过传递依赖did->location 实现的。也就是说，sid不直接决定非主属性location。 
　　解决目地：每个关系模式中不能留有传递依赖。 
　　解决方法：分为两个关系 s（sid，sname，did），d（dno，dname，location） 
　　注意：关系s中必须有外关键字did。否则两个关系之间失去联系。
 
### BCNF：如果关系模式R（U，F）的所有属性（包括主属性和非主属性）都不传递依赖于R的任何候选关键字，那么称关系R是属于BCNF的。或是关系模式R中，每个决定因素都包含关键字（而不是被关键字所包含）。 
例：配件管理关系模式 wpe（wid，pid，eid，qnt）分别表仓库号，配件号，职工号，数量。有以下条件:
　　a.一个仓库有多个职工。 
　　b.一个职工仅在一个仓库工作。 
　　c.每个仓库里一种型号的配件由专人负责，但一个人可以管理几种配件。 
　　d.同一种型号的配件可以分放在几个仓库中。 
　　分析：
　　1. pid不能确定qnt，由组合属性（wid，pid）来决定，存在函数依赖（wid，pid）-> qnt。
　　2. 每个仓库里的一种配件由专人负责，而一个人可以管理几种配件，所以有（wid，pid）-> eid。
　　3. 一个职工仅在一个仓库工作，有eid -> wid。
　　4. 每个仓库里的一种配件由专人负责，而一个职工仅在一个仓库工作，有（eid，pid）-> qnt。 
　　找一下候选关键字。因为（wid，pid）-> qnt，（wid，pid）-> eid，因此（wid，pid）可以决定整个元组，是一个候选关键字。根据eid -> wid，（eid，pid）-> qnt，故（eid，pid）也能决定整个元组，为另一个候选关键字。属性eid，eid，pid 均为主属性，只有一个非主属性qnt。它对任何一个候选关键字都是完全函数依赖的，并且是直接依赖，所以该关系模式是3NF。 

　　分析一下主属性。因为eid -> wid，主属性eid是wid的决定因素，但是它本身不是关键字，只是组合关键字的一部分。这就造成主属性wid对另外一个候选关键字（eid，pid）的部分依赖，因为（eid，pid）-> eid但反过来不成立，而pid -> wid，故（eid，pid）-> wid 也是传递依赖。 　
　　虽然没有非主属性对候选关键字的传递依赖，但存在主属性对候选关键字的传递依赖，同样也会带来麻烦。如一个新职工分配到仓库工作，但暂时处于实习阶段，没有独立负责对某些配件的管理任务。由于缺少关键字的一部分pid而无法插入到该关系中去。又如某个人改成不管配件了去负责安全，则在删除配件的同时该职工也会被删除。 
　　解决办法：分成管理ep（eid，pid，qnt），关键字是（eid，pid）和工作ew（eid，wid）其关键字是eid 
　　缺点：分解后函数依赖的保持性较差。如此例中，由于分解，函数依赖（wid，pid）-> eid 丢失了，因而对原来的语义有所破坏。没有体现出每个仓库里一种部件由专人负责。有可能出现一部件由两个人或两个以上的人来同时管理。因此，分解之后的关系模式降低了部分完整性约束。
　　
　　一个关系分解成多个关系，要使得分解有意义，起码的要求是分解后不丢失原来的信息。这些信息不仅包括数据本身，而且包括由函数依赖所表示的数据之间的相互制约。进行分解的目标是达到更高一级的规范化程度，但是分解的同时必须考虑两个问题：无损联接性和保持函数依赖。有时往往不可能做到既有无损联接性，又完全保持函数依赖。需要根据需要进行权衡。
1NF直到BCNF的四种范式之间有如下关系： 
BCNF包含了3NF包含2NF包含1NF

### 小结： 
- 目的：规范化目的是使结构更合理，消除存储异常，使数据冗余尽量小，便于插入、删除和更新 
- 原则：遵从概念单一化原则，即一个关系模式描述一个实体或实体间的一种联系。规范的实质就是概念的单一化。 
- 方法：将关系模式投影分解成两个或两个以上的关系模式。 
- 要求：分解后的关系模式集合应当与原关系模式"等价"，即经过自然联接可以恢复原关系而不丢失信息，并保持属性间合理的联系。

