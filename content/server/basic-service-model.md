---
title: "Basic Service Model 基本服务模型"
date: 2023-02-18T12:58:46+08:00
keywords: ["server"]
categories: ["server"]
tags: ["server"]
series: [""]
draft: true
toc: false
related:
  threshold: 50
  includeNewer: true
  toLower: false
  indices:
  - name: keywords
    weight: 100
  - name: tags
    weight: 90
  - name: categories
    weight: 50
  - name: date
    weight: 10
---

服务器的高并发是指可以在同一时间支持较多的客户端连接和数据请求。
高性能是指服务器程序能流畅、低延迟地应答客户端的各类请求。

一个服务性能不仅仅取决于服务所在机器的硬件配置（内存，cpu，磁盘，网络带宽等）,还取决于软件层面上服务器程序的逻辑结构设计。

### 网络通信组件效率

#### 高效网络通信框架设计原则

##### 1. 尽量少等待

流行的网络通信框架很多，如libevent,libuv,boost asio等

一个好的网络通信框架至少要解决以下7个问题

- 1.如何检测有新的客户端连接到来
- 2.如何接受客户端的连接请求
- 3.如何检测客户端是否有数据发送过来
- 4.如何收取客户端发送到数据
- 5.如何检测异常的客户端连接，检测到之后如何处理
- 6.如何向客户端发送数据
- 7.如何在客户端发送完数据后关闭连接

对于第1、3个问题，使用I/O复用技术的select、poll、epoll等相关套接字函数

对于第2个问题，使用socket api accept函数

对于第4个问题，使用recv函数

对于第6个问题，使用send函数

> 从程序的角度来说高性能、高并发服务只是一个或一组程序，一般来说，能尽量满足尽量少等待原则的程序就是高性能的

几个工作效率不是最优的网络通信的例子：

- 默认情况下，载recv函数没有数据时，线程会阻塞在recv函数调用处
- 默认情况下，如果tcp窗口不是足够大，则数据无法发出，send函数也会阻塞当前调用线程
- 默认情况下，connect函数发起连接时会有一定时长的阻塞
- 向对端发送一段数据，接着使用recv函数接收对端的应答数据，如果对端一直不应答，当前调用线程就会阻塞在recv函数调用处

在网络通信中，有些等待不是必须的，那么有没有一种方法，使上述过程不需要等待？最好是不仅不需要等待，而且在网络操作完成时能通知我们，
利用等待的时间让程序做其他事情，答案是肯定的，使用 **`I/O复用技术`** 即可。

##### 2. 尽量减少做无用功的时间

目前windows支持的I/O复用技术有select、WSAAsyncSelect、WSAEventSelect和IOCP.
Linux支持的I/O复用技术有select、poll和epoll模型。

- 第一级：select和poll
- 第二级：WSAAsyncSelect、WSAEventSelect、IOCP、epoll

第一级函数本质上是在一定事件内主动查询一组socket句柄上是否有网络事件。
第二级函数相当于变主动查询为被动通知，即网络事件发生时，系统会通知我们处理。

例如connect函数发起连接时，如果将连接socket设置为非阻塞模式，程序就不会等待connect函数的放回结果，立即返回，等连接完成之后，epoll模型会生成EPOLLOUT事件通知我们

总之，对网络通信组件的性能有高要求时，尽量不要主动查询各个socket事件，而是等待操作系统通知我们。

> 尽量减少做无用功的时间，对于有大量的任务要处理、需要支持高并发服务等情况，这样做优势很明显

> 如果使用I/O复用技术，如果某个socket失效，应该及时从I/O复用api上移除该socket，否则可能造成死循环或浪费cpu检测周期问题

##### 3. 检测网络事件的高效做法

在高性能服务器设计中一般将socket设置成非阻塞模式，利用I/O复用检测各个socket上的事件。

#### 连接的被动关闭和主动关闭

##### 长连接和短链接

### 原始的服务器结构

```c++
// 初始化阶段
while(true){
  // 利用accept函数接受连接，产生客户端fd

  // 利用步骤2中的fd与某个客户端通信
}
// 资源清理
```

### Reactor模式

Reactor模式是一种事件处理设计模式，在I/O请求到达后，服务处理程序使用I/O复用技术同步地将这些请求派发给相关的请求处理程序。

多路复用器(I/O复用器)可以将数量众多的输入输出请求分发给有限的处理程序。

一个Reactor模式结构如下：

- 资源请求事件
- 多路复用器与事件分发器
- 事件处理器

### 一个线程对应一个循环思想

#### 基本结构

```c++
void* thread_func(void* thread_arg)
{
  // 这里做一些需要对初始化工作
  while(线程退出标志){
    // 步骤一：利用select/poll/epoll等I/O复用技术分离出读写事件
    // 步骤二：处理读事件和写事件
    // 步骤三：做其他事情
  }
  // 这里做一些清理工作
}
```

#### 线程的分工

主线程负责调用accept函数产生新的客户端连接并生成相应的socket，然后将这些新连接的socket传递给另外数个工作线程。
