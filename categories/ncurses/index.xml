<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ncurses on Realjf&#39;s blog</title>
    <link>https://realjf.io/categories/ncurses/</link>
    <description>Recent content in Ncurses on Realjf&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 05 Mar 2021 14:36:09 +0800</lastBuildDate>
    
	<atom:link href="https://realjf.io/categories/ncurses/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>NCURSES编程 之 19 工具和小部件库 19 Tools and Widget Libraries</title>
      <link>https://realjf.io/ncurses/19-tools-and-widget-libraries/</link>
      <pubDate>Fri, 05 Mar 2021 14:36:09 +0800</pubDate>
      
      <guid>https://realjf.io/ncurses/19-tools-and-widget-libraries/</guid>
      <description>19 工具和小部件库 现在您已经看到了NCURSE及其姊妹库的功能，您将为一个严重操纵屏幕的项目卷起袖子，准备就绪。但是等等。。在普通的NCURSE中，甚至在附加库中编写和维护复杂的GUI小部件可能相当困难。有一些现成的工具和小部件库可以用来代替编写自己的小部件。您可以使用其中的一些，从代码中获取想法，甚至扩展它们。
19.1. CDK（CUSSES开发工具包） 用作者的话说
CDK代表“curses开发工具包”，目前它包含21个随时可用的小部件，这有助于全屏幕诅咒程序的快速开发。
该工具包提供了一些有用的小部件，这些小部件可以直接用于程序中。它写得很好，文档也很好。示例目录中的示例可以是初学者的一个好开始。CDK可从中下载http://insigner-island.net/cdk/. 按照README文件中的说明安装。
19.1.1。小部件列表 下面是cdk提供的小部件列表及其描述。
Widget Type Quick Description =========================================================================== Alphalist Allows a user to select from a list of words, with the ability to narrow the search list by typing in a few characters of the desired word. Buttonbox This creates a multiple button widget. Calendar Creates a little simple calendar widget. Dialog Prompts the user with a message, and the user can pick an answer from the buttons provided.</description>
    </item>
    
    <item>
      <title>NCURSES编程 之 18.表单库 18 Forms Library</title>
      <link>https://realjf.io/ncurses/18-forms-library/</link>
      <pubDate>Fri, 05 Mar 2021 14:35:46 +0800</pubDate>
      
      <guid>https://realjf.io/ncurses/18-forms-library/</guid>
      <description>18 表单库 好。如果您在web页面上看到过这些表单，这些表单从用户那里获取输入并执行各种操作，您可能会想知道，任何人都会如何在文本模式显示中创建这样的表单。用平淡的语言写那些漂亮的表格是相当困难的。表单库试图提供一个基本的框架来轻松地构建和维护表单。它有很多特性（功能）来管理验证、字段的动态扩展等。。让我们看看它的全部流程。
表单是字段的集合；每个字段可以是标签（静态文本）或数据输入位置。表单库还提供了将表单划分为多个页面的函数。
18.1. 基础知识 表单的创建方式与菜单基本相同。首先，使用new_field（）创建与表单相关的字段。您可以为字段设置选项，以便它们可以显示一些奇特的属性，在字段失去焦点之前进行验证等。。然后字段被附加到窗体。在此之后，可以将表单发布到显示，并准备接收输入。在与menu_driver（）类似的行中，使用form_driver（）操作窗体。我们可以发送请求以形成驱动程序，将焦点移动到某个字段，将光标移动到字段的末尾等。。用户在字段中输入值并完成验证后，可以取消对窗体的过帐，并释放分配的内存。
窗体程序的一般控制流如下所示。
 初始化curses 使用new_field（）创建字段。可以指定字段的高度和宽度及其在窗体上的位置。 通过指定要附加的字段，使用new_form（）创建表单。 使用form_Post（）发布表单并刷新屏幕。 使用循环处理用户请求，并使用表单驱动程序对表单进行必要的更新。 使用menu_Unpost（）取消菜单的粘贴 通过Free_form（）释放分配给菜单的内存 使用Free_field（）释放分配给项目的内存 结束curses  如您所见，使用表单库与处理菜单库非常相似。下面的例子将探讨表单处理的各个方面。让我们从一个简单的例子开始。第一。
18.2. 用表单库编译 要使用表单库函数，必须包含form.h，并且要将程序与表单库链接，标志-lform应按顺序与-lncurs一起添加。
#include &amp;lt;form.h&amp;gt; . . . compile and link: gcc &amp;lt;program file&amp;gt; -lform -lncurses  表单示例
#include &amp;lt;form.h&amp;gt; int main() { FIELD *field[3]; FORM *my_form; int ch; /* Initialize curses */ initscr(); cbreak(); noecho(); keypad(stdscr, TRUE); /* Initialize the fields */ field[0] = new_field(1, 10, 4, 18, 0, 0); field[1] = new_field(1, 10, 6, 18, 0, 0); field[2] = NULL; /* Set field options */ set_field_back(field[0], A_UNDERLINE); /* Print a line for the option */ field_opts_off(field[0], O_AUTOSKIP); /* Don&#39;t go to next field when this */ /* Field is filled up */ set_field_back(field[1], A_UNDERLINE); field_opts_off(field[1], O_AUTOSKIP); /* Create the form and post it */ my_form = new_form(field); post_form(my_form); refresh(); mvprintw(4, 10, &amp;quot;Value 1:&amp;quot;); mvprintw(6, 10, &amp;quot;Value 2:&amp;quot;); refresh(); /* Loop through to get user requests */ while((ch = getch()) !</description>
    </item>
    
    <item>
      <title>NCURSES编程 之 17.菜单库 17 Menus Library</title>
      <link>https://realjf.io/ncurses/17-menus-library/</link>
      <pubDate>Fri, 05 Mar 2021 14:35:25 +0800</pubDate>
      
      <guid>https://realjf.io/ncurses/17-menus-library/</guid>
      <description>17 菜单库 菜单库提供了基本curses的一个很好的扩展，通过它可以创建菜单。它提供了一组创建菜单的函数。但是，他们必须定制，以提供更好的外观，颜色等。让我们进入细节。
菜单是一个屏幕显示，它帮助用户选择给定项目集的某些子集。简单地说，菜单是一个项目集合，其中一个或多个项目可以从中选择。有些读者可能不知道多个项目选择功能。菜单库提供了编写菜单的功能，用户可以从中选择多个项目作为首选选项。这将在后面的一节中讨论。现在是时候开始做一些基础知识了。
17.1。基础知识 要创建菜单，首先创建项目，然后将菜单张贴到显示。之后，所有用户响应的处理都是在优雅的函数menu_driver（）中完成的，该菜单是任何菜单程序的工作马。
菜单程序的控制流程如下所示。
 初始化curses 使用new炣item（）创建项目。可以为项目指定名称和说明。 通过指定要附加的项，使用new_menu（）创建菜单。 使用menu_Post（）发布”菜单，然后刷新屏幕。 使用循环处理用户请求，并使用菜单“驱动程序”对菜单进行必要的更新。 用menu_Unpost（）取消对菜单的选中” 释放由free_menu（）分配给菜单的内存 释放分配给项目的内存（使用free_item（） 结束curses  让我们看看一个程序，它打印一个简单的菜单，并用上下箭头更新当前选择。
17.2. 使用菜单库编译 要使用菜单库函数，您必须包括menu.h，并且要将程序与菜单库链接，则应按此顺序添加标记-lmenu和-lncurs。
#include &amp;lt;menu.h&amp;gt; . . . compile and link: gcc &amp;lt;program file&amp;gt; -lmenu -lncurses  菜单基础
#include &amp;lt;curses.h&amp;gt; #include &amp;lt;menu.h&amp;gt; #define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0])) #define CTRLD 4 char *choices[] = { &amp;quot;Choice 1&amp;quot;, &amp;quot;Choice 2&amp;quot;, &amp;quot;Choice 3&amp;quot;, &amp;quot;Choice 4&amp;quot;, &amp;quot;Exit&amp;quot;, }; int main() { ITEM **my_items; int c; MENU *my_menu; int n_choices, i; ITEM *cur_item; initscr(); cbreak(); noecho(); keypad(stdscr, TRUE); n_choices = ARRAY_SIZE(choices); my_items = (ITEM **)calloc(n_choices + 1, sizeof(ITEM *)); for(i = 0; i &amp;lt; n_choices; ++i) my_items[i] = new_item(choices[i], choices[i]); my_items[n_choices] = (ITEM *)NULL; my_menu = new_menu((ITEM **)my_items); mvprintw(LINES - 2, 0, &amp;quot;F1 to Exit&amp;quot;); post_menu(my_menu); refresh(); while((c = getch()) !</description>
    </item>
    
    <item>
      <title>NCURSES编程 之 16 平面库 16 Panel Library</title>
      <link>https://realjf.io/ncurses/16-panel-library/</link>
      <pubDate>Fri, 05 Mar 2021 11:04:04 +0800</pubDate>
      
      <guid>https://realjf.io/ncurses/16-panel-library/</guid>
      <description>16 平面库 既然你精通curses，你就想做些大事。您创建了许多重叠的窗口，以提供专业的窗口类型外观。不幸的是，很快就很难管理这些。多次刷新、更新让你陷入噩梦。每当你忘记按正确的顺序刷新窗口时，重叠的窗口就会产生斑点。
不要绝望。panels库提供了一个优雅的解决方案。用网络课程开发者的话说
如果您的界面设计使得windows在运行时可能会深入可见性堆栈或弹出到顶层，那么所产生的簿记可能会很乏味，而且很难正确进行。因此，面板库。
如果你有很多重叠的窗口，那么面板库是一个不错的选择。它消除了执行一系列wnoutrefresh（）、doupdate（）的需要，并且减轻了正确执行的负担（自下而上）。该库维护有关窗口顺序、重叠和正确更新屏幕的信息。为什么要等？让我们仔细看一下面板。
16.1. 基础知识 面板对象是一个窗口，它被隐式地视为包含所有其他面板对象的面板的一部分。甲板被视为一个堆垛，顶部面板完全可见，其他面板根据其位置可能会或可能不会被遮挡。因此，基本思想是创建一个重叠面板的堆栈，并使用面板库来正确显示它们。有一个类似于refresh（）的函数，它在调用时按正确的顺序显示面板。提供隐藏或显示面板、移动面板、更改其大小等功能。在所有调用这些函数的过程中，重叠问题由panels库管理。
面板程序的一般流程如下： - 创建要附加到面板的窗口（使用newwin（））。 - 使用选定的可见性顺序创建面板。根据需要的能见度把它们叠起来。函数new_panel（）用于创建面板。 - 调用update_panels（）将面板以正确的可见性顺序写入虚拟屏幕。执行doupdate（）以在屏幕上显示它。 - 用show_panel（）、hide_panel（）、move_panel（）等填充面板。使用panel_hidden（）和panel_window（）等辅助函数。使用用户指针存储面板的自定义数据。使用函数set_panel_userptr（）和panel_userptr（）设置并获取面板的用户指针。 - 完成面板操作后，请使用del_panel（）删除面板。
让我们用一些程序把概念弄清楚。下面是一个简单的程序，它创建了3个重叠面板并在屏幕上显示它们。
16.2. 使用面板库编译 要使用panels库函数，必须包含panel.h，并且要将程序与panels库链接起来，标志-lpanel应该按顺序与-lncurs一起添加。
#include &amp;lt;panel.h&amp;gt; . . . compile and link: gcc &amp;lt;program file&amp;gt; -lpanel -lncurses  示例：
#include &amp;lt;panel.h&amp;gt; int main() { WINDOW *my_wins[3]; PANEL *my_panels[3]; int lines = 10, cols = 40, y = 2, x = 4, i; initscr(); cbreak(); noecho(); /* Create windows for the panels */ my_wins[0] = newwin(lines, cols, y, x); my_wins[1] = newwin(lines, cols, y + 1, x + 5); my_wins[2] = newwin(lines, cols, y + 2, x + 10); /* * Create borders around the windows so that you can see the effect * of panels */ for(i = 0; i &amp;lt; 3; ++i) box(my_wins[i], 0, 0); /* Attach a panel to each window */ /* Order is bottom up */ my_panels[0] = new_panel(my_wins[0]); /* Push 0, order: stdscr-0 */ my_panels[1] = new_panel(my_wins[1]); /* Push 1, order: stdscr-0-1 */ my_panels[2] = new_panel(my_wins[2]); /* Push 2, order: stdscr-0-1-2 */ /* Update the stacking order.</description>
    </item>
    
    <item>
      <title>NCURSES编程 之 15其他库 15 Other Libraries</title>
      <link>https://realjf.io/ncurses/15-other-libraries/</link>
      <pubDate>Fri, 05 Mar 2021 11:01:11 +0800</pubDate>
      
      <guid>https://realjf.io/ncurses/15-other-libraries/</guid>
      <description>15 其他库 除了curses库之外，很少有文本模式库提供更多的功能和很多特性。以下部分解释了三个标准库，它们通常与curses一起分发。</description>
    </item>
    
    <item>
      <title>NCURSES编程 之 14 其他特性 14 Miscellaneous Features</title>
      <link>https://realjf.io/ncurses/14-miscellaneous-features/</link>
      <pubDate>Fri, 05 Mar 2021 10:56:49 +0800</pubDate>
      
      <guid>https://realjf.io/ncurses/14-miscellaneous-features/</guid>
      <description>14 其他特性 现在你知道了足够的功能来编写一个好的诅咒程序，所有的钟和口哨。有一些在各种情况下有用的杂项函数。让我们直奔其中一些。
14.1. 光标集（） 此函数可用于使光标不可见。此函数的参数应为
 0 : invisible or 1 : normal or 2 : very visible.  14.2. 暂时离开curses模式 有时您可能想暂时回到熟食模式（正常行缓冲模式）。在这种情况下，首先需要通过调用def_prog_mode（）保存tty模式，然后调用endwin（）结束curses模式。这将使您处于原来的tty模式。完成后，要返回到curses，请调用reset_prog_mode（）。此函数用于将tty返回到def_prog_mode（）存储的状态。然后执行refresh（），您将返回到诅咒模式。下面是一个例子，展示了要做的事情的顺序。
例12。暂时离开诅咒模式
#include &amp;lt;ncurses.h&amp;gt; int main() { initscr(); /* Start curses mode */ printw(&amp;quot;Hello World !!!\n&amp;quot;); /* Print Hello World */ refresh(); /* Print it on to the real screen */ def_prog_mode(); /* Save the tty modes */ endwin(); /* End curses mode temporarily */ system(&amp;quot;/bin/sh&amp;quot;); /* Do whatever you like in cooked mode */ reset_prog_mode(); /* Return to the previous tty mode*/ /* stored by def_prog_mode() */ refresh(); /* Do refresh() to restore the */ /* Screen contents */ printw(&amp;quot;Another String\n&amp;quot;); /* Back to curses use the full */ refresh(); /* capabilities of curses */ endwin(); /* End curses mode */ return 0; }  14.</description>
    </item>
    
    <item>
      <title>NCURSES编程 之 13. 屏幕操作 13 Screen Manipulation</title>
      <link>https://realjf.io/ncurses/13-screen-manipulation/</link>
      <pubDate>Fri, 05 Mar 2021 10:52:56 +0800</pubDate>
      
      <guid>https://realjf.io/ncurses/13-screen-manipulation/</guid>
      <description>13 屏幕操作 在本节中，我们将研究一些函数，这些函数允许我们高效地管理屏幕并编写一些奇特的程序。这在编写游戏时尤其重要。
13.1. getyx（）函数 函数getyx（）可以用来找出当前光标的坐标。它将填充给定参数中的x和y坐标值。因为getyx（）是一个宏，所以不必传递变量的地址。它可以称为
getyx(win, y, x); /* win: window pointer * y, x: y, x co-ordinates will be put into this variables */  函数getparyx（）获取子窗口相对于主窗口的起始坐标。这有时对更新子窗口很有用。在设计诸如编写多个菜单之类的花哨东西时，很难存储菜单位置、它们的第一个选项坐标等。解决这个问题的一个简单方法是在子窗口中创建菜单，然后使用getparyx（）找到菜单的起始坐标。
函数getbegyx（）和getmaxyx（）存储当前窗口的起始坐标和最大坐标。这些函数在有效管理窗口和子窗口方面的作用与上述方法相同。
13.2. 屏幕转储 在编写游戏时，有时需要存储屏幕的状态并将其恢复到相同的状态。函数scr_dump（）可用于将屏幕内容转储到作为参数给定的文件中。以后可以通过scr_restore功能恢复。这两个简单的函数可以有效地用来维护一个快速移动的游戏和不断变化的场景。
13.3. 窗口转储 要存储和还原窗口，可以使用函数putwin（）和getwin（）。putwin（）将当前窗口状态放入一个文件中，稍后可以由getwin（）还原。
函数copywin（）可用于将一个窗口完全复制到另一个窗口上。它以源窗口和目标窗口为参数，根据指定的矩形，将矩形区域从源窗口复制到目标窗口。它的最后一个参数指定是覆盖还是只覆盖目标窗口上的内容。如果此参数为真，则复制是非破坏性的。</description>
    </item>
    
    <item>
      <title>NCURSES编程 之 12.鼠标接口 12 Interfacing With the Mouse</title>
      <link>https://realjf.io/ncurses/12-interfacing-with-the-mouse/</link>
      <pubDate>Fri, 05 Mar 2021 10:44:02 +0800</pubDate>
      
      <guid>https://realjf.io/ncurses/12-interfacing-with-the-mouse/</guid>
      <description>12 鼠标接口 现在您已经了解了如何获取键，让我们从鼠标执行相同的操作。通常每个UI都允许用户与键盘和鼠标进行交互。
12.1. 基础知识 在执行任何其他操作之前，必须使用mousemask（）启用要接收的事件。
mousemask( mmask_t newmask, /* The events you want to listen to */ mmask_t *oldmask) /* The old events mask */  上面函数的第一个参数是您想要监听的事件的位掩码。默认情况下，将关闭所有事件。位掩码ALL_MOUSE_EVENTS 可用于获取所有事件。
以下是所有事件掩码：
Name Description --------------------------------------------------------------------- BUTTON1_PRESSED mouse button 1 down BUTTON1_RELEASED mouse button 1 up BUTTON1_CLICKED mouse button 1 clicked BUTTON1_DOUBLE_CLICKED mouse button 1 double clicked BUTTON1_TRIPLE_CLICKED mouse button 1 triple clicked BUTTON2_PRESSED mouse button 2 down BUTTON2_RELEASED mouse button 2 up BUTTON2_CLICKED mouse button 2 clicked BUTTON2_DOUBLE_CLICKED mouse button 2 double clicked BUTTON2_TRIPLE_CLICKED mouse button 2 triple clicked BUTTON3_PRESSED mouse button 3 down BUTTON3_RELEASED mouse button 3 up BUTTON3_CLICKED mouse button 3 clicked BUTTON3_DOUBLE_CLICKED mouse button 3 double clicked BUTTON3_TRIPLE_CLICKED mouse button 3 triple clicked BUTTON4_PRESSED mouse button 4 down BUTTON4_RELEASED mouse button 4 up BUTTON4_CLICKED mouse button 4 clicked BUTTON4_DOUBLE_CLICKED mouse button 4 double clicked BUTTON4_TRIPLE_CLICKED mouse button 4 triple clicked BUTTON_SHIFT shift was down during button state change BUTTON_CTRL control was down during button state change BUTTON_ALT alt was down during button state change ALL_MOUSE_EVENTS report all button state changes REPORT_MOUSE_POSITION report mouse movement  12.</description>
    </item>
    
    <item>
      <title>NCURSES编程 之 11.键盘接口 11 Interfacing With the Keyboard</title>
      <link>https://realjf.io/ncurses/11-interfacing-with-the-keyboard/</link>
      <pubDate>Fri, 05 Mar 2021 10:39:16 +0800</pubDate>
      
      <guid>https://realjf.io/ncurses/11-interfacing-with-the-keyboard/</guid>
      <description>11. 键盘接口 11.1. 基础知识 没有强大的用户界面就没有完整的GUI，要与用户交互，curses程序应该对用户的按键或鼠标动作敏感。我们先来处理按键吧。
正如您在上面几乎所有的示例中所看到的，从用户那里获取按键输入非常容易。获取按键的一种简单方法是使用getch（）函数。当您对读取单个按键点击而不是完整的文本行（通常以回车结束）感兴趣时，应启用cbreak模式来读取按键。应启用键盘以获取功能键、箭头键等。有关详细信息，请参阅初始化部分。
getch（）返回与按下的键对应的整数。如果是普通字符，则整数值将与字符等效。否则，它将返回一个可以与curses.h中定义的常量匹配的数字。例如，如果用户按F1，则返回的整数为265。可以使用curses.h中定义的宏KEY_F()来检查这一点。这使得读取键便于携带和管理。 例如，如果像这样调用getch（）
int ch; ch = getch();  getch（）将等待用户按键（除非指定了超时），当用户按键时，将返回相应的整数。然后，您可以使用curses.h中定义的常量检查返回的值，以便与所需的键匹配。
下面的代码段将完成这项工作。
if(ch == KEY_LEFT) printw(&amp;quot;Left arrow is pressed\n&amp;quot;);  让我们编写一个小程序，创建一个菜单，可以通过上下箭头导航。
11.2 一个简单的按键使用示例 #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;ncurses.h&amp;gt; #define WIDTH 30 #define HEIGHT 10 int startx = 0; int starty = 0; char *choices[] = { &amp;quot;Choice 1&amp;quot;, &amp;quot;Choice 2&amp;quot;, &amp;quot;Choice 3&amp;quot;, &amp;quot;Choice 4&amp;quot;, &amp;quot;Exit&amp;quot;, }; int n_choices = sizeof(choices) / sizeof(char *); void print_menu(WINDOW *menu_win, int highlight); int main() { WINDOW *menu_win; int highlight = 1; int choice = 0; int c; initscr(); clear(); noecho(); cbreak(); /* Line buffering disabled.</description>
    </item>
    
    <item>
      <title>NCURSES编程 之 10.颜色 10 Colors</title>
      <link>https://realjf.io/ncurses/10-colors/</link>
      <pubDate>Fri, 05 Mar 2021 10:20:17 +0800</pubDate>
      
      <guid>https://realjf.io/ncurses/10-colors/</guid>
      <description>10. 颜色 10.1. 基础知识 没有色彩的生活似乎单调乏味。诅咒有一个很好的机制来处理颜色。让我们用一个小程序来深入了解这些事情。
#include &amp;lt;ncurses.h&amp;gt; void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string); int main(int argc, char *argv[]) { initscr(); /* Start curses mode */ if(has_colors() == FALSE) { endwin(); printf(&amp;quot;Your terminal does not support color\n&amp;quot;); exit(1); } start_color(); /* Start color */ init_pair(1, COLOR_RED, COLOR_BLACK); attron(COLOR_PAIR(1)); print_in_middle(stdscr, LINES / 2, 0, 0, &amp;quot;Viola !!! In color ...&amp;quot;); attroff(COLOR_PAIR(1)); getch(); endwin(); } void print_in_middle(WINDOW *win, int starty, int startx, int width, char *string) { int length, x, y; float temp; if(win == NULL) win = stdscr; getyx(win, y, x); if(startx !</description>
    </item>
    
    <item>
      <title>NCURSES编程 之 9.窗口 9 Windows</title>
      <link>https://realjf.io/ncurses/9-windows/</link>
      <pubDate>Fri, 05 Mar 2021 10:11:03 +0800</pubDate>
      
      <guid>https://realjf.io/ncurses/9-windows/</guid>
      <description>9. 窗口 窗口是curses中最重要的概念。您已经看到了上面的标准窗口stdscr，其中所有函数都隐式地操作这个窗口。现在要使设计成为一个最简单的GUI，您需要借助windows。使用windows的主要原因可能是为了提高效率，通过只更新需要更改的窗口和更好的设计来分别操作部分屏幕。我想说，最后一个原因是最重要的，在去windows。你应该一直努力在你的程序中有一个更好的，易于管理的设计。如果您正在编写大型、复杂的gui，那么在开始做任何事情之前，这一点至关重要。
9.1. 基础知识 可以通过调用函数newwin（）来创建窗口。实际上，它不会在屏幕上产生任何东西。它为一个结构分配内存来操作窗口，并用有关窗口的数据（如大小、beginy、beginx等）更新结构。。因此，在curses中，窗口只是一个虚构窗口的抽象，可以独立于屏幕的其他部分进行操作。函数newwin（）返回指向结构窗口的指针，该指针可以传递给与窗口相关的函数，如wprintw（）等。。最后，可以使用delwin（）销毁窗口。它将释放与窗口结构关联的内存。
9.2. 让这里有一扇窗户！！！ 如果创建了一个窗口而我们看不到它，那有什么好玩的呢。所以有趣的部分从展示窗口开始。函数box（）可用于在窗口周围绘制边框。让我们在本例中更详细地探讨这些函数。
例7。窗口边框示例
#include &amp;lt;ncurses.h&amp;gt; WINDOW *create_newwin(int height, int width, int starty, int startx); void destroy_win(WINDOW *local_win); int main(int argc, char *argv[]) { WINDOW *my_win; int startx, starty, width, height; int ch; initscr(); /* Start curses mode */ cbreak(); /* Line buffering disabled, Pass on * everty thing to me */ keypad(stdscr, TRUE); /* I need that nifty F1 */ height = 3; width = 10; starty = (LINES - height) / 2; /* Calculating for a center placement */ startx = (COLS - width) / 2; /* of the window */ printw(&amp;quot;Press F1 to exit&amp;quot;); refresh(); my_win = create_newwin(height, width, starty, startx); while((ch = getch()) !</description>
    </item>
    
    <item>
      <title>NCURSES编程 之 8.属性 8 Attributes</title>
      <link>https://realjf.io/ncurses/8-attributes/</link>
      <pubDate>Fri, 05 Mar 2021 09:43:14 +0800</pubDate>
      
      <guid>https://realjf.io/ncurses/8-attributes/</guid>
      <description>8. 属性 我们已经看到了如何使用属性打印具有某些特殊效果的字符的示例。如果谨慎地设置属性，可以以简单易懂的方式呈现信息。下面的程序将一个C文件作为输入并打印带有粗体注释的文件。扫描代码。
一个简单的属性例子：
/* pager functionality by Joseph Spainhour&amp;quot; &amp;lt;spainhou@bellsouth.net&amp;gt; */ #include &amp;lt;ncurses.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; int main(int argc, char *argv[]) { int ch, prev, row, col; prev = EOF; FILE *fp; int y, x; if(argc != 2) { printf(&amp;quot;Usage: %s &amp;lt;a c file name&amp;gt;\n&amp;quot;, argv[0]); exit(1); } fp = fopen(argv[1], &amp;quot;r&amp;quot;); if(fp == NULL) { perror(&amp;quot;Cannot open input file&amp;quot;); exit(1); } initscr(); /* Start curses mode */ getmaxyx(stdscr, row, col); /* find the boundaries of the screeen */ while((ch = fgetc(fp)) !</description>
    </item>
    
    <item>
      <title>NCURSES编程 之 7.输入函数 7 Input Functions</title>
      <link>https://realjf.io/ncurses/7-input-functions/</link>
      <pubDate>Fri, 05 Mar 2021 09:14:52 +0800</pubDate>
      
      <guid>https://realjf.io/ncurses/7-input-functions/</guid>
      <description> 7. 输入函数 好吧，不用输入就打印，很无聊。让我们看看允许我们从用户那里获取输入的函数。这些功能也可以分为三类。 - getch（）类：获取字符 - scanw（）类：获取格式化输入 - getstr（）类：获取字符串
7.1. getch（）函数类 这些函数从终端读取单个字符。但有一些微妙的事实需要考虑。例如，如果不使用函数cbreak（），curses将不会连续读取输入字符，而是仅在遇到新行或EOF后才开始读取。为了避免这种情况，必须使用cbreak（）函数，以便程序可以立即使用字符。另一个广泛使用的函数是noecho（）。顾名思义，当设置（使用）这个函数时，用户输入的字符不会显示在屏幕上。两个函数cbreak（）和noecho（）是密钥管理的典型示例。这一类型的功能在密钥管理部分进行了说明。
7.2. scanw（）函数类 这些函数类似于scanf（），增加了从屏幕上任何位置获取输入的功能。
7.2.1. scanw（）和mvscanw 这些函数的用法类似于sscanf（），其中要扫描的行由wgetstr（）函数提供。也就是说，这些函数调用wgetstr（）函数（如下所述），并使用结果行进行扫描。
7.2.2. wscanw（）和mvwscanw（） 这些函数类似于上面的两个函数，只是它们从一个窗口中读取，该窗口作为这些函数的参数之一提供。
7.2.3. vwscanw（） 此函数类似于vscanf（）。当要扫描的参数数目可变时，可以使用此选项。
7.3. getstr（）函数类 这些函数用于从终端获取字符串。本质上，此函数执行的任务与对getch（）的一系列调用相同，直到收到换行符、回车符或文件结尾。结果字符串由str指向，str是用户提供的字符指针。
7.4. 一些例子 例4。一个简单的scanw示例
#include &amp;lt;ncurses.h&amp;gt; /* ncurses.h includes stdio.h */ #include &amp;lt;string.h&amp;gt; int main() { char mesg[]=&amp;quot;Enter a string: &amp;quot;; /* message to be appeared on the screen */ char str[80]; int row,col; /* to store the number of rows and * * the number of colums of the screen */ initscr(); /* start the curses mode */ getmaxyx(stdscr,row,col); /* get the number of rows and columns */ mvprintw(row/2,(col-strlen(mesg))/2,&amp;quot;%s&amp;quot;,mesg); /* print the message at the center of the screen */ getstr(str); mvprintw(LINES - 2, 0, &amp;quot;You Entered: %s&amp;quot;, str); getch(); endwin(); return 0; }  </description>
    </item>
    
    <item>
      <title>NCURSES编程 之 6.输出函数 6 Output Functions</title>
      <link>https://realjf.io/ncurses/6-output-functions/</link>
      <pubDate>Fri, 05 Mar 2021 00:23:31 +0800</pubDate>
      
      <guid>https://realjf.io/ncurses/6-output-functions/</guid>
      <description>6. 输出函数 我想你已经等不及要看一些行动了。回到我们的curses之旅。现在curses已经初始化，让我们和世界互动。
有三类函数可用于在屏幕上进行输出。 - addch（）类：打印带有属性的单个字符 - printw（）类：类似printf（）的打印格式化输出 - addstr（）类：打印字符串 这些函数可以互换使用，使用哪一个类是风格问题。让我们详细看看每一个。
6.1 addch() 类的函数 这些函数将单个字符放入当前光标位置，并推进光标的位置。您可以指定要打印的字符，但它们通常用于打印具有某些属性的字符。属性将在文档的后面部分详细解释。如果角色与属性（粗体、反转视频等）关联，则当curses打印角色时，它将在该属性中打印。
要将角色与某些属性组合在一起，有两个选项：
 通过使用所需的属性宏或单个字符。这些属性宏可以在头文件ncurses.h中找到。例如，要打印粗体加下划线的字符ch（char类型），可以调用addch（），如下所示。 cpp addch(ch | A_BOLD | A_UNDERLINE);  通过使用类似attrset（）、attron（）、attroff（）的函数。这些函数在属性部分进行了说明。简单地说，它们操纵给定窗口的当前属性。设置后，窗口中打印的字符将与属性相关联，直到关闭为止。  此外，curses为基于字符的图形提供了一些特殊字符。可以绘制表格、水平线或垂直线等。可以在头文件ncurses.h中找到所有可用字符。请尝试在该文件中查找以ACS_开头的宏。
6.2 mvaddch(),waddch()和 mvwaddch() mvaddch()用于移动光标到指定点，然后打印，因此，如下调用：
move(row,col); /* moves the cursor to rowth row and colth column */ addch(ch);  可以代替
mvaddch(row,col,ch);  waddch（）与addch（）类似，只是它将字符添加到给定的窗口中。（请注意，addch（）将一个字符添加到窗口stdscr中。）
以类似的方式，mvwaddch（）函数用于在给定的坐标处将字符添加到给定的窗口中。
现在，我们熟悉了基本的输出函数addch（）。但是，如果我们想打印一个字符串，那么逐字打印会非常烦人。幸运的是，ncurses提供了printf-like或puts-like函数。
6.3. printw（）函数类 这些函数类似于printf（），增加了在屏幕上任何位置打印的功能。
6.3.1. printw（）和mvprintw 这两个函数的工作方式与printf（）非常相似。mvprintw（）可用于将光标移动到某个位置，然后打印。如果要先移动光标，然后使用printw（）函数打印，请先使用move（），然后使用printw（），尽管我看不出为什么要避免使用mvprintw（），但您可以灵活地进行操作。
6.3.2. wprintw（）和mvwprintw 这两个函数与上述两个函数类似，只是它们打印在作为参数给出的相应窗口中。
6.3.3. vwprintw（） 此函数类似于vprintf（）。当要打印可变数量的参数时，可以使用此选项。
6.3.4. 一个简单的printw示例 #include &amp;lt;ncurses.h&amp;gt; /* ncurses.</description>
    </item>
    
    <item>
      <title>NCURSES编程 之 5.关于Windows的一句话 5 a Word About Windows</title>
      <link>https://realjf.io/ncurses/5-a-word-about-windows/</link>
      <pubDate>Fri, 05 Mar 2021 00:07:39 +0800</pubDate>
      
      <guid>https://realjf.io/ncurses/5-a-word-about-windows/</guid>
      <description>5. 关于Windows的一句话 在我们深入讨论无数的ncurses函数之前，让我先澄清一下windows的一些问题。窗口将在以下部分中详细说明
窗口是由curses系统定义的假想屏幕。窗口并不意味着通常在Win9X平台上看到的有边框的窗口。初始化curses时，它会创建一个名为stdscr的默认窗口，该窗口表示80x25（或正在运行的窗口的大小）屏幕。如果您正在执行一些简单的任务，如打印一些字符串、读取输入等，那么您可以安全地将此窗口用于所有目的。您还可以创建窗口并调用显式在指定窗口上工作的函数。
例如，如果你打调用
printw(&amp;quot;Hi There !!!&amp;quot;); refresh();  它在当前光标位置打印stdscr上的字符串。类似地，对refresh（）的调用仅适用于stdscr。 假设你已经创建了windows，那么你就必须调用一个在普通函数中加了w的函数。
wprintw(win, &amp;quot;Hi There !!!&amp;quot;); wrefresh(win);  正如您将在文档的其余部分看到的，函数的命名遵循相同的约定。对于每个函数，通常还有三个以上的函数。
printw(string); /* Print on stdscr at present cursor position */ mvprintw(y, x, string);/* Move to (y, x) then print string */ wprintw(win, string); /* Print on window win at present cursor position */ /* in the window */ mvwprintw(win, y, x, string); /* Move to (y, x) relative to window */ /* co-ordinates and then print */  无w函数通常是以stdscr作为窗口参数展开为相应w函数的宏。</description>
    </item>
    
    <item>
      <title>NCURSES编程 之 4.初始化 4 Initialization</title>
      <link>https://realjf.io/ncurses/4-initialization/</link>
      <pubDate>Thu, 04 Mar 2021 23:49:20 +0800</pubDate>
      
      <guid>https://realjf.io/ncurses/4-initialization/</guid>
      <description>4. 初始化 我们现在知道，要初始化curses系统，必须调用initscr（）函数。在初始化之后可以调用一些函数来定制curses会话。我们可以要求curses系统将终端设置为原始模式或初始化颜色或初始化鼠标等。。让我们来讨论一些通常在initscr（）之后立即调用的函数；
4.1. 初始化函数 4.2. raw（）和cbreak（） 通常，终端驱动程序缓冲用户键入的字符，直到遇到新行或回车符。但是大多数程序要求用户一输入字符就可以使用。以上两个函数用于禁用行缓冲。这两个函数之间的区别在于将suspend（CTRL-Z）、interrupt和quit（CTRL-C）等控制字符传递给程序的方式。在raw（）模式下，这些字符直接传递给程序而不生成信号。在cbreak（）模式下，终端驱动程序将这些控制字符解释为任何其他字符。我个人更喜欢使用raw（），因为我可以更好地控制用户的行为。
4.3. echo（）和noecho（） 这些函数控制用户键入的字符回显到终端。noecho（）关闭回声。这样做的原因可能是为了更好地控制回音，或者在通过getch（）等函数获取用户的输入时抑制不必要的回音。大多数交互式程序在初始化时调用noecho（），并以可控的方式进行字符回音。它使程序员能够灵活地在窗口的任何位置回显字符，而无需更新当前（y，x）坐标。
4.4. keypad（） 这是我最喜欢的初始化函数。它可以读取功能键，如F1、F2、箭头键等。几乎每个交互式程序都可以这样做，因为箭头键是任何用户界面的主要部分。设置 keypad（stdscr，TRUE）为常规屏幕（stdscr）启用此功能。您将在本文档后面的部分了解有关密钥管理的更多信息。
4.5. halfdelay（） 这个函数虽然不经常使用，但有时还是很有用的。调用halfdelay（）以启用半延迟模式，这与cbreak（）模式类似，因为键入的字符可立即用于程序。但是，如果没有可用的输入，它会等待十分之一秒的“X”输入，然后返回ERR，X&amp;rsquo;是传递给函数halfdelay（）的超时值。当您想请求用户输入时，此函数非常有用，如果用户在某个时间内没有响应，我们可以执行其他操作。一个可能的例子是密码提示超时。
4.6. 其他初始化函数 初始化时调用的函数很少，可以自定义curses行为。它们没有像上面提到的那样广泛使用。在适当的地方对其中的一些问题进行了解释。
4.7. 一个例子 让我们写一个程序来阐明这些函数的用法。
例2。初始化函数用法示例
#include &amp;lt;ncurses.h&amp;gt; int main() { int ch; initscr(); /* Start curses mode */ raw(); /* Line buffering disabled */ keypad(stdscr, TRUE); /* We get F1, F2 etc.. */ noecho(); /* Don&#39;t echo() while we do getch */ printw(&amp;quot;Type any character to see it in bold\n&amp;quot;); ch = getch(); /* If raw() hadn&#39;t been called * we have to press enter before it * gets to the program */ if(ch == KEY_F(1)) /* Without keypad enabled this will */ printw(&amp;quot;F1 Key pressed&amp;quot;);/* not get to us either */ /* Without noecho() some ugly escape * charachters might have been printed * on screen */ else { printw(&amp;quot;The pressed key is &amp;quot;); attron(A_BOLD); printw(&amp;quot;%c&amp;quot;, ch); attroff(A_BOLD); } refresh(); /* Print it on to the real screen */ getch(); /* Wait for user input */ endwin(); /* End curses mode */ return 0; }  这个程序是不言自明的。但我使用的函数还没有解释。函数getch（）用于从用户获取字符。它相当于普通的getchar（），只是我们可以禁用行缓冲以避免在输入之后。有关getch（）和读取密钥的更多信息，请参阅密钥管理部分。函数attron和attroff分别用于打开和关闭某些属性。在这个例子中，我用它们以粗体打印字符。这些功能将在后面详细说明。</description>
    </item>
    
    <item>
      <title>3 the Gory Details</title>
      <link>https://realjf.io/ncurses/3-the-gory-details/</link>
      <pubDate>Thu, 04 Mar 2021 23:48:17 +0800</pubDate>
      
      <guid>https://realjf.io/ncurses/3-the-gory-details/</guid>
      <description>3. 血淋淋的细节 现在我们已经看到了如何编写一个简单的curses程序，让我们进入细节。有许多功能可以帮助您自定义屏幕上看到的内容，还有许多功能可以充分利用。
我们走吧。。。</description>
    </item>
    
    <item>
      <title>NCURSES编程 之 2.Hell World 2 Hello World</title>
      <link>https://realjf.io/ncurses/2-hello-world/</link>
      <pubDate>Thu, 04 Mar 2021 23:34:00 +0800</pubDate>
      
      <guid>https://realjf.io/ncurses/2-hello-world/</guid>
      <description>2 Hello World!!! 欢迎来到curses的世界。在我们深入到库中并研究它的各种特性之前，让我们编写一个简单的程序并向世界问好。
2.1 编译NCURSES库 要使用ncurses库函数，必须在程序中包含ncurses.h。要将程序与ncurses链接，应添加标志-lncurses。
#include &amp;lt;ncurses.h&amp;gt; . . . compile and link: gcc &amp;lt;program file&amp;gt; -lncurses  例子1. Hello World!!!程序
#include &amp;lt;ncurses.h&amp;gt; int main() { initscr(); /* Start curses mode */ printw(&amp;quot;Hello World !!!&amp;quot;); /* Print Hello World */ refresh(); /* Print it on to the real screen */ getch(); /* Wait for user input */ endwin(); /* End curses mode */ return 0; }  2.</description>
    </item>
    
    <item>
      <title>NCURSES编程 之 1.简介 1 Introduction</title>
      <link>https://realjf.io/ncurses/1-introduction/</link>
      <pubDate>Thu, 04 Mar 2021 22:53:29 +0800</pubDate>
      
      <guid>https://realjf.io/ncurses/1-introduction/</guid>
      <description>1. 简介 在老式电传终端时代，终端远离计算机，通过串行电缆与计算机相连。终端可以通过发送一系列字节来配置。终端的所有功能（如将光标移动到新位置、擦除部分屏幕、滚动屏幕、更改模式等）都可以通过这些字节序列访问。这些控制序列通常称为转义序列，因为它们以转义（0x1B）字符开头。即使在今天，通过适当的仿真，我们也可以将转义序列发送到仿真器，并在终端窗口上实现相同的效果。
假设你想用彩色打印一行。试着在你的控制台上输入这个。
echo &amp;quot;^[[0;31;40mIn Color&amp;quot;  第一个字符是转义字符，看起来像两个字符^和[。要打印它，您必须按CTRL+V，然后按ESC键（或者直接用\033代替）。其他的都是普通的可打印字符。你应该可以看到红色的字符串“In Color”。它保持这种方式，并恢复到原来的模式类型。
echo &amp;quot;^[[0;37;40m&amp;quot;  现在，这些神奇的字符是什么意思？难以理解？对于不同的终端，它们甚至可能是不同的。因此UNIX的设计者发明了一种叫做termcap的机制。它是一个文件，列出了特定终端的所有功能，以及实现特定效果所需的转义序列。在后来的几年里，它被terminfo所取代。这种机制不需要深入研究太多细节，它允许应用程序查询terminfo数据库并获取要发送到终端或终端仿真器的控制字符。
1.1 什么是NCURSES？ 你可能想知道，这些技术上的胡言乱语有什么意义。在上述场景中，每个应用程序都应该查询terminfo并执行必要的操作（发送控制字符等）。很快就很难处理这种复杂性，这就产生了“CURSES”。Curses是“cursor optimization”这个名字的双关语。Curses库在使用原始终端代码时形成了一个包装器，并提供了高度灵活和高效的API（应用程序编程接口）。它提供了移动光标、创建窗口、生成颜色、玩鼠标等功能。应用程序不必担心底层的终端功能。
那么什么是NCURSES？NCURSES是原始systemv 4.0版（SVr4）curses的克隆。它是一个可自由分发的库，与旧版本的curses完全兼容。简而言之，它是一个函数库，用于管理应用程序在字符单元终端上的显示。在本文档的其余部分中，术语“curses”和“ncurses”可以互换使用。
NCURSES的详细历史记录可以在源发行版的新闻文件中找到。当前包由托马斯·迪基维护。你可以联系维修人员bug-ncurses@gnu.org。
1.2 用NCURSES我们可以做什么？ NCURSES不仅在终端功能上创建了一个包装器，而且还提供了一个健壮的框架来在文本模式下创建美观的UI（用户界面）。它提供了创建窗口等函数。它的姊妹库面板、菜单和窗体提供了对基本curses库的扩展。这些库通常伴随着curses。可以创建包含多个窗口、菜单、面板和窗体的应用程序。窗口可以独立管理，可以提供“滚动性”，甚至可以隐藏。
菜单为用户提供了一个简单的命令选择选项。窗体允许创建易于使用的数据输入和显示窗口。面板扩展了ncurses处理重叠和堆叠窗口的功能。
这些只是我们可以用ncurses做的一些基本的事情。随着我们的讲述，我们将看到这些库的所有功能。
1.3 哪里可以获取到？ 好吧，现在你知道你能用ncurses做什么了，你必须开始了。NCURSES通常随安装一起提供。如果你没有这个库或者想自己编译它，请继续阅读。
编译包 NCURSES 可从ftp://ftp.gnu.org/pub/gnu/ncurses/ncurses.tar.gz或任何http://www.gnu.org/order/ftp.html中提到的ftp站点。
阅读自述文件和安装文件，了解如何安装它的详细信息。它通常包括以下操作。
# 解压 tar zxvf ncurses&amp;lt;version&amp;gt;.tar.gz # 进入目录 cd ncurses&amp;lt;version&amp;gt; # 配置构建信息 ./configure # 构建 make # 安装 make install  使用rpm NCURSES RPM 能在http://rpmfind.net中找到并下载，然后安装它
rpm -i &amp;lt;downloaded rpm&amp;gt;  1.4 该文档的目的/范围 本文档旨在成为使用ncurses及其姊妹库进行编程的“一体式”指南。我们从一个简单的“helloworld”程序毕业到更复杂的表单操作。假设没有ncurses的经验。写作是非正式的，但是每一个例子都提供了很多细节。
1.5 关于编程 文档中的所有程序都以压缩格式提供这里。解压缩和解压。目录结构如下所示。
ncurses | |----&amp;gt; JustForFun -- just for fun programs |----&amp;gt; basics -- basic programs |----&amp;gt; demo -- output files go into this directory after make | | | |----&amp;gt; exe -- exe files of all example programs |----&amp;gt; forms -- programs related to form library |----&amp;gt; menus -- programs related to menus library |----&amp;gt; panels -- programs related to panels library |----&amp;gt; perl -- perl equivalents of the examples (contributed | by Anuradha Ratnaweera) |----&amp;gt; Makefile -- the top level Makefile |----&amp;gt; README -- the top level README file.</description>
    </item>
    
  </channel>
</rss>