<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Opengl on Realjf&#39;s blog</title>
    <link>https://realjf.io/categories/opengl/</link>
    <description>Recent content in Opengl on Realjf&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 10 May 2021 11:30:39 +0800</lastBuildDate>
    
	<atom:link href="https://realjf.io/categories/opengl/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>opengl之五 纹理 Textures</title>
      <link>https://realjf.io/opengl/textures/</link>
      <pubDate>Mon, 10 May 2021 11:30:39 +0800</pubDate>
      
      <guid>https://realjf.io/opengl/textures/</guid>
      <description>纹理 纹理是一个2D图片（甚至也有1D和3D的纹理），它可以用来添加物体的细节；你可以想象纹理是一张绘有砖块的纸，无缝折叠贴合到你的3D的房子上，这样你的房子看起来就像有砖墙外表了。因为可以在一张图片上插入非常多的细节，这样就可以让物体非常精细而不用指定额外的顶点。
为了能够把纹理映射(Map)到三角形上，需要指定三角形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个纹理坐标(Texture Coordinate)，用来标明该从纹理图像的哪个部分采样。之后在图形的其它片段上进行片段插值(Fragment Interpolation)。
纹理坐标在x和y轴上，范围为0到1之间（注意使用的是2D纹理图像）。使用纹理坐标获取纹理颜色叫做采样(Sampling)。纹理坐标起始于(0, 0)，也就是纹理图片的左下角，终始于(1, 1)，即纹理图片的右上角。下面的图片展示了如何把纹理坐标映射到三角形上的。
为三角形指定了3个纹理坐标点。如上图所示，三角形的左下角对应纹理的左下角，因此把三角形左下角顶点的纹理坐标设置为(0, 0)；三角形的上顶点对应于图片的上中位置所以把它的纹理坐标设置为(0.5, 1.0)；同理右下方的顶点设置为(1, 0)。只要给顶点着色器传递这三个纹理坐标就行了，接下来它们会被传片段着色器中，它会为每个片段进行纹理坐标的插值。
纹理坐标看起来像是这样的：
float texCoords[] = { 0.0f, 0.0f, // 左下角 1.0f, 0.0f, // 右下角 0.5f, 1.0f // 上中 };  纹理环绕方式 纹理坐标的范围通常是从(0, 0)到(1, 1)，如果把纹理坐标设置在范围之外，OpenGL默认的行为是重复这个纹理图像（基本上忽略浮点纹理坐标的整数部分），但OpenGL提供了更多的选择：
   环绕方式 描述     GL_REPEAT 对纹理的默认行为，重复纹理图像   GL_MIRRORED_REPEAT 和GL_REPEAT一样，但每次重复图片是镜像放置的   GL_CLAMP_TO_EDGE 纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果   GL_CLAMP_TO_BORDER 超出的坐标为用户指定的边缘颜色    当纹理超出范围时的效果：
前面提到的每个选项都可以使用glTexParameter*函数对单独的一个坐标轴设置（s、t如果是使用3D纹理那么还有一个r），他们和x、y、z是等价的。
glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT); glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT);   第一个参数指定了纹理目标；使用的是2D纹理，因此纹理目标是GL_TEXTURE_2D。 第二个参数需要指定设置的选项与应用的纹理轴。打算配置的是WRAP选项，并且指定S和T轴。 最后一个参数需要传递一个环绕方式(Wrapping)  如果选择GL_CLAMP_TO_BORDER选项，还需要指定一个边缘的颜色。这需要使用glTexParameter函数的fv后缀形式，用GL_TEXTURE_BORDER_COLOR作为它的选项，并且传递一个float数组作为边缘的颜色值：</description>
    </item>
    
    <item>
      <title>opengl之四 着色器和uniform Shader and Uniform</title>
      <link>https://realjf.io/opengl/shader-and-uniform/</link>
      <pubDate>Mon, 10 May 2021 10:11:54 +0800</pubDate>
      
      <guid>https://realjf.io/opengl/shader-and-uniform/</guid>
      <description>着色器(Shader)是运行在GPU上的小程序。这些小程序为图形渲染管线的某个特定部分而运行。从基本意义上来说，着色器只是一种把输入转化为输出的程序。着色器也是一种非常独立的程序，因为它们之间不能相互通信；它们之间唯一的沟通只有通过输入和输出。
GLSL 着色器是使用一种叫GLSL的类C语言写成的
着色器的开头总是要声明版本，接着是输入和输出变量、uniform和main函数。每个着色器的入口点都是main函数，在这个函数中我们处理所有的输入变量，并将结果输出到输出变量中。
一个典型的着色器程序：
#version version_number in type in_variable_name; in type in_variable_name; out type out_variable_name; uniform type uniform_name; int main() { // 处理输入并进行一些图形操作 ... // 输出处理过的结果到输出变量 out_variable_name = weird_stuff_we_processed; }  在顶点着色器上，每个输入变量也叫顶点属性，能声明的顶点属性是有上限的，由硬件决定。 opengl至少有16个包含4分量的顶点属性可用，可以通过查询GL_MAX_VERTEX_ATTRIBS来获取具体上限。
int nrAttributes; glGetIntegerv(GL_MAX_VERTEX_ATTRIBS, &amp;amp;nrAttributes); std::cout &amp;lt;&amp;lt; &amp;quot;Maximum nr of vertex attributes supported: &amp;quot; &amp;lt;&amp;lt; nrAttributes &amp;lt;&amp;lt; std::endl;  数据类型 glsl中包含C等其他语言大部分的默认基础类型：int、float、double、uint和bool。 glsl也有两种容器，分别是向量（Vector）和矩阵（Matrix）
向量 glsl中的向量是一个包含有1、 2、 3或者4个分量的容器，分量的类型可以是基础类型的任意一个，可以是如下类型：
   类型 含义     vecn 包含n个float分量的默认向量   bvecn 包含n个bool分量的向量   ivecn 包含n个int分量的向量   uvecn 包含n个unsigned int分量的向量   dvecn 包含n个double分量的向量    一个向量的分量可以通过vec.</description>
    </item>
    
    <item>
      <title>opengl之三 顶点属性与索引缓冲对象 Vertex Attribute and Element Buffer Object</title>
      <link>https://realjf.io/opengl/vertex-attribute-and-element-buffer-object/</link>
      <pubDate>Mon, 10 May 2021 08:53:34 +0800</pubDate>
      
      <guid>https://realjf.io/opengl/vertex-attribute-and-element-buffer-object/</guid>
      <description>顶点属性 顶点着色器允许指定任何以顶点属性为形式的输入。 所以，必须在渲染前指定OpenGL该如何解释顶点数据。
顶点缓冲对象（Vertex Buffer Object, VBO）:
 位置数据被存储为32位（4字节）浮点值 每个位置包含3个这样的值 在这三个值之间没有空隙，这几个值在数组中紧密排列 数据中第一个值在缓冲开始的位置  有了这些信息，可以使用glVertexAttribPointer函数告诉opengl该如何解析顶点数据：
glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);   第一个参数指定要配置的顶点属性。顶点着色器使用layout(location=0)定义了position顶点属性的位置值，它可以把顶点属性值设置为0，因此这里用0传入。 第二个参数指定顶点属性的大小。顶点属性是一个vec3，它由三个值组成，所以大小是3。 第三个参数指定数据的类型，这里是GL_FLOAT(GLSL中vec*都是由浮点数值组成的) 第四个参数定义是否希望数据被标准化，如果设置为GL_TRUE，所有数据都会被映射到0到1之间，这里设置为GL_FALSE。 第五个参数定义步长（Stride），指定在连续的顶点属性组之间的间隔。由于下一组位置数据在3个float之后，所以设置步长为3*sizeof(float)，需注意数组是紧密排列的，也可以设置0让opengl决定具体步长是多少。 最后一个参数类型是void*，需进行强制类型转换，表示位置数据在缓冲中起始位置的偏移量（offset）。由于位置数据在数组的开头，所以这里是0.  每个顶点属性从一个VBO管理的内存中获得它的数据，而具体是从哪个VBO（程序中可以有多个VBO）获取则是通过在调用glVertexAttribPointer时绑定到GL_ARRAY_BUFFER的VBO决定的。由于在调用glVertexAttribPointer之前绑定的是先前定义的VBO对象，顶点属性0现在会链接到它的顶点数据。
glEnableVertexAttribArray(0);  使用glEnableVertexAttribArray启用顶点属性，以顶点属性位置值作为参数启用顶点属性，默认是禁用的。
完整的代码如下：
// 0. 复制顶点数组到缓冲中供OpenGL使用 glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); // 1. 设置顶点属性指针 glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0); glEnableVertexAttribArray(0); // 2. 当渲染一个物体时要使用着色器程序 glUseProgram(shaderProgram); // 3. 绘制物体 ...  顶点数组对象 顶点数组对象(Vertex Array Object, VAO)，可以像顶点缓冲对象那样被绑定，任何随后的顶点属性调用都会储存在这个VAO中。这样的好处就是，当配置顶点属性指针时，你只需要将那些调用执行一次，之后再绘制物体的时候只需要绑定相应的VAO就行了。</description>
    </item>
    
    <item>
      <title>opengl之二 使用Opengl画一个三角形快速开始 Draw Triangles Quick Start</title>
      <link>https://realjf.io/opengl/draw-triangles-quick-start/</link>
      <pubDate>Sat, 08 May 2021 16:04:07 +0800</pubDate>
      
      <guid>https://realjf.io/opengl/draw-triangles-quick-start/</guid>
      <description>在上一篇 opengl 快速开始 的基础上，我们画一个三角形，并着色。
opengl渲染过程 了解三种缓冲对象  顶点数组对象：Vertex Array Object，VAO 顶点缓冲对象：Vertex Buffer Object，VBO 索引缓冲对象：Element Buffer Object，EBO或Index Buffer Object，IBO  图形渲染管线 图形渲染管线实际上是一堆原始图形数据途径一个输送管道，期间经过各种变化处理最终出现在屏幕的过程。
图形渲染管线分为两部分：
 第一部分把你的3d坐标转换为2d坐标 第二部分把2d坐标转变为实际的有颜色的像素   2D坐标和像素也是不同的，2D坐标精确表示一个点在2D空间中的位置，而2D像素是这个点的近似值，2D像素受到你的屏幕/窗口分辨率的限制。
 着色器 图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。 GPU为每个（渲染管线）阶段运行各自的小程序，这个小程序叫做着色器。opengl着色器用opengl着色器语言（OpenGL Shading Language, GLSL）写成。
渲染过程各个阶段  要注意蓝色部分代表的是我们可以注入自定义的着色器的部分
 顶点数据 首先用包含3个3d坐标的数组作为数据输入，这个数组叫顶点数据（Vertex Data），顶点数据使用顶点属性表示的。
顶点着色器 顶点着色器主要的目的是把3D坐标转为另一种3D坐标，同时顶点着色器允许我们对顶点属性进行一些基本处理。
图元装配 图元装配(Primitive Assembly)阶段将顶点着色器输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并所有的点装配成指定图元的形状；
几何着色器 几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状
光栅化阶段 这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率
片段着色器 主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色。
alpha测试和混合阶段 这个阶段检测片段的对应的深度（和模板(Stencil)）值，用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查alpha值（alpha值定义了一个物体的透明度）并对物体进行混合(Blend)。
准备 main.cpp原始内容如下：
#include &amp;lt;glad/glad.h&amp;gt; #include &amp;lt;GLFW/glfw3.h&amp;gt; #include &amp;lt;iostream&amp;gt; void framebuffer_size_callback(GLFWwindow* window, int width, int height); void processInput(GLFWwindow *window); const unsigned int SCR_WIDTH = 800; const unsigned int SCR_HEIGHT = 600; int main() { glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // create window GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, &amp;quot;LearnOpenGL&amp;quot;, NULL, NULL); if (window == NULL) { std::cout &amp;lt;&amp;lt; &amp;quot;Failed to create GLFW window&amp;quot; &amp;lt;&amp;lt; std::endl; glfwTerminate(); return -1; } glfwMakeContextCurrent(window); // viewport size glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); // init glad if(!</description>
    </item>
    
    <item>
      <title>opengl之一 快速开始 Opengl Quick Start</title>
      <link>https://realjf.io/opengl/opengl-quick-start/</link>
      <pubDate>Fri, 07 May 2021 19:45:37 +0800</pubDate>
      
      <guid>https://realjf.io/opengl/opengl-quick-start/</guid>
      <description>准备  Ubuntu OS v20.04 glfw v3.3.4 glad  gl v4.6 core  cmake v3.18.4  目录结构 . ├── CMakeLists.txt ├── deps │ ├── glad │ │ ├── include │ │ │ ├── glad │ │ │ │ └── glad.h │ │ │ └── KHR │ │ │ └── khrplatform.h │ │ └── src │ │ └── glad.c │ └── glfw ├── preinstall.sh ├── src │ ├── CMakeLists.txt │ ├── glad.</description>
    </item>
    
    <item>
      <title>如何从源码构建GLFW How to Compile Glfw From Source</title>
      <link>https://realjf.io/opengl/how-to-compile-glfw-from-source/</link>
      <pubDate>Sat, 23 Jan 2021 00:47:53 +0800</pubDate>
      
      <guid>https://realjf.io/opengl/how-to-compile-glfw-from-source/</guid>
      <description>首先glfw下载 https://www.glfw.org/download.html
下载源码包后，开始安装
 环境：debian-10  构建 unzip glfw-3.3.2.zip mkdir glfw-build cd glfw-build cmake ..  报错如下：
-- The C compiler identification is GNU 10.2.0 -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Check for working C compiler: /usr/bin/cc - skipped -- Detecting C compile features -- Detecting C compile features - done -- Looking for pthread.h -- Looking for pthread.h - found -- Performing Test CMAKE_HAVE_LIBC_PTHREAD -- Performing Test CMAKE_HAVE_LIBC_PTHREAD - Failed -- Looking for pthread_create in pthreads -- Looking for pthread_create in pthreads - not found -- Looking for pthread_create in pthread -- Looking for pthread_create in pthread - found -- Found Threads: TRUE -- Found Doxygen: /usr/bin/doxygen (found version &amp;quot;1.</description>
    </item>
    
  </channel>
</rss>