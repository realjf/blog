<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>opengl on Realjf&#39;s blog</title>
    <link>https://realjf.io/categories/opengl/</link>
    <description>Recent content in opengl on Realjf&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 08 May 2021 16:04:07 +0800</lastBuildDate><atom:link href="https://realjf.io/categories/opengl/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>使用Opengl画一个三角形快速开始 Draw Triangles Quick Start</title>
      <link>https://realjf.io/opengl/draw-triangles-quick-start/</link>
      <pubDate>Sat, 08 May 2021 16:04:07 +0800</pubDate>
      
      <guid>https://realjf.io/opengl/draw-triangles-quick-start/</guid>
      <description>在上一篇 opengl 快速开始 的基础上，我们画一个三角形，并着色。
opengl渲染过程 了解三种缓冲对象  顶点数组对象：Vertex Array Object，VAO 顶点缓冲对象：Vertex Buffer Object，VBO 索引缓冲对象：Element Buffer Object，EBO或Index Buffer Object，IBO  图形渲染管线 图形渲染管线实际上是一堆原始图形数据途径一个输送管道，期间经过各种变化处理最终出现在屏幕的过程。
图形渲染管线分为两部分：
 第一部分把你的3d坐标转换为2d坐标 第二部分把2d坐标转变为实际的有颜色的像素   2D坐标和像素也是不同的，2D坐标精确表示一个点在2D空间中的位置，而2D像素是这个点的近似值，2D像素受到你的屏幕/窗口分辨率的限制。
 着色器 图形渲染管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且很容易并行执行。 GPU为每个（渲染管线）阶段运行各自的小程序，这个小程序叫做着色器。opengl着色器用opengl着色器语言（OpenGL Shading Language, GLSL）写成。
渲染过程各个阶段  要注意蓝色部分代表的是我们可以注入自定义的着色器的部分
 顶点数据 首先用包含3个3d坐标的数组作为数据输入，这个数组叫顶点数据（Vertex Data），顶点数据使用顶点属性表示的。
顶点着色器 顶点着色器主要的目的是把3D坐标转为另一种3D坐标，同时顶点着色器允许我们对顶点属性进行一些基本处理。
图元装配 图元装配(Primitive Assembly)阶段将顶点着色器输出的所有顶点作为输入（如果是GL_POINTS，那么就是一个顶点），并所有的点装配成指定图元的形状；
几何着色器 几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状
光栅化阶段 这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)。在片段着色器运行之前会执行裁切(Clipping)。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率
片段着色器 主要目的是计算一个像素的最终颜色，这也是所有OpenGL高级效果产生的地方。通常，片段着色器包含3D场景的数据（比如光照、阴影、光的颜色等等），这些数据可以被用来计算最终像素的颜色。
alpha测试和混合阶段 这个阶段检测片段的对应的深度（和模板(Stencil)）值，用它们来判断这个像素是其它物体的前面还是后面，决定是否应该丢弃。这个阶段也会检查alpha值（alpha值定义了一个物体的透明度）并对物体进行混合(Blend)。
准备 main.cpp原始内容如下：
#include &amp;lt;glad/glad.h&amp;gt;#include &amp;lt;GLFW/glfw3.h&amp;gt;#include &amp;lt;iostream&amp;gt; void framebuffer_size_callback(GLFWwindow* window, int width, int height); void processInput(GLFWwindow *window); const unsigned int SCR_WIDTH = 800; const unsigned int SCR_HEIGHT = 600; int main() { glfwInit(); glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // create window  GLFWwindow* window = glfwCreateWindow(SCR_WIDTH, SCR_HEIGHT, &amp;#34;LearnOpenGL&amp;#34;, NULL, NULL); if (window == NULL) { std::cout &amp;lt;&amp;lt; &amp;#34;Failed to create GLFW window&amp;#34; &amp;lt;&amp;lt; std::endl; glfwTerminate(); return -1; } glfwMakeContextCurrent(window); // viewport size  glfwSetFramebufferSizeCallback(window, framebuffer_size_callback); // init glad  if(!</description>
    </item>
    
    <item>
      <title>opengl快速开始 Opengl Quick Start</title>
      <link>https://realjf.io/opengl/opengl-quick-start/</link>
      <pubDate>Fri, 07 May 2021 19:45:37 +0800</pubDate>
      
      <guid>https://realjf.io/opengl/opengl-quick-start/</guid>
      <description>准备  Ubuntu OS v20.04 glfw v3.3.4 glad  gl v4.6 core   cmake v3.18.4  目录结构 . ├── CMakeLists.txt ├── deps │ ├── glad │ │ ├── include │ │ │ ├── glad │ │ │ │ └── glad.h │ │ │ └── KHR │ │ │ └── khrplatform.h │ │ └── src │ │ └── glad.c │ └── glfw ├── preinstall.sh ├── src │ ├── CMakeLists.txt │ ├── glad.</description>
    </item>
    
    <item>
      <title>如何从源码构建GLFW How to Compile Glfw From Source</title>
      <link>https://realjf.io/opengl/how-to-compile-glfw-from-source/</link>
      <pubDate>Sat, 23 Jan 2021 00:47:53 +0800</pubDate>
      
      <guid>https://realjf.io/opengl/how-to-compile-glfw-from-source/</guid>
      <description>首先glfw下载 https://www.glfw.org/download.html
下载源码包后，开始安装
 环境：debian-10  构建 unzip glfw-3.3.2.zip mkdir glfw-build cd glfw-build cmake .. 报错如下：
-- The C compiler identification is GNU 10.2.0 -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Check for working C compiler: /usr/bin/cc - skipped -- Detecting C compile features -- Detecting C compile features - done -- Looking for pthread.h -- Looking for pthread.h - found -- Performing Test CMAKE_HAVE_LIBC_PTHREAD -- Performing Test CMAKE_HAVE_LIBC_PTHREAD - Failed -- Looking for pthread_create in pthreads -- Looking for pthread_create in pthreads - not found -- Looking for pthread_create in pthread -- Looking for pthread_create in pthread - found -- Found Threads: TRUE -- Found Doxygen: /usr/bin/doxygen (found version &amp;#34;1.</description>
    </item>
    
  </channel>
</rss>
