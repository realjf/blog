<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golangs on Real_JF&#39;s blog</title>
    <link>https://realjf.io/golang/</link>
    <description>Recent content in Golangs on Real_JF&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 17 Oct 2019 19:13:36 +0800</lastBuildDate>
    
	<atom:link href="https://realjf.io/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Golang语言标准库之 sync.Pool临时对象池</title>
      <link>https://realjf.io/golang/sync-pool/</link>
      <pubDate>Thu, 17 Oct 2019 19:13:36 +0800</pubDate>
      
      <guid>https://realjf.io/golang/sync-pool/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Golang语言标准库之 sync/atomic原子操作</title>
      <link>https://realjf.io/golang/sync-atomic/</link>
      <pubDate>Thu, 17 Oct 2019 17:37:02 +0800</pubDate>
      
      <guid>https://realjf.io/golang/sync-atomic/</guid>
      <description>原子操作，顾名思义是不可分割的，他可以是一个步骤，也可以是多个步骤，其执行过程不会被线程调度机制打断的操作。
 原子性不可能由软件单独保证，需要硬件的支持，因此和架构有关。在x86架构平台下，cpu提供了在指令执行期间对总线加锁的手段。
CPU芯片上有一条引线#HLOCK pin，如果汇编语言的程序中在一条指令前面加上前缀&amp;rdquo;LOCK&amp;rdquo;，经过汇编以后的机器代码就使CPU在执行这条指令的时候把#HLOCK pin的电位拉低，
持续到这条指令结束时放开，从而把总线锁住，这样同一总线上别的CPU就暂时不能通过总线访问内存了，保证了这条指令在多处理器环境中的原子性。
 sync/atomic包的文件结构以及数据结构可以参考这里
sync/atomic包提供了6中操作数据类型 - int32 - uint32 - int64 - uint64 - uintptr - unsafe.Pointer
分别为这每种数据类型提供了五种操作 - add 增减 - load 载入 - store 存储 - compareandswap 比较并交换 - swap 交换
下面以int32为例，具体使用上面五种操作实现原子操作 AddInt32操作 var val int32 val = 10 atomic.AddInt32(&amp;amp;val, 10) // 对于无符号32位即uint32，则需要使用二进制补码进行操作 var val2 uint32 val2 = 10 atomic.AddUint32(&amp;amp;val2, ^uint32(10 - 1)) // 等价于 val2 - 10  CompareAndSwapInt32 对比并交换是指先判断addr指向的值是否与参数old一致，如果一致就用new值替换addr的值，最后返回成功，具体例子如下
package main import ( &amp;quot;fmt&amp;quot; &amp;quot;sync&amp;quot; &amp;quot;sync/atomic&amp;quot; ) func main() { var val int32 wg := sync.</description>
    </item>
    
    <item>
      <title>golang性能分析利器之Pprof</title>
      <link>https://realjf.io/golang/pprof/</link>
      <pubDate>Tue, 19 Mar 2019 15:14:16 +0800</pubDate>
      
      <guid>https://realjf.io/golang/pprof/</guid>
      <description>pprof是golang程序一个性能分析的工具，可以查看堆栈、cpu信息等
pprof有2个包：net/http/pprof以及runtime/pprof
二者之间的关系：net/http/pprof包只是使用runtime/pprof包来进行封装了一下，并在http端口上暴露出来
性能分析利器 pprof go本身提供的工具链有： - runtime/pprof：采集程序的运行数据进行分析 - net/http/pprof：采集HTTP Server的运行时数据进行分析
pprof以profile.proto读取分析样本的集合，并生成报告以可视化并帮助分析数据
 profile.proto是一个Protocol Buffer v3的描述文件，它描述了一组callstack和symbolization信息，作用是表示统计分析的一组采样的调用栈，是很常见的stacktrace配置文件格式
 使用方式  Report generation：报告生成 Interactive terminal use：交互式终端使用 Web interface：Web界面  1. web服务器方式 假如你的go呈现的是用http包启动的web服务器，当想要看web服务器的状态时，选择【net/http/pprof】，使用方法如下：
&amp;quot;net/http&amp;quot; _ &amp;quot;net/http/pprof&amp;quot;  查看结果：通过访问：http://domain:port/debug/pprof查看当前web服务的状态
2. 服务进程 如果你go程序是一个服务进程，同样可以选择【net/http/pprof】包，然后开启另外一个goroutine来开启端口监听
// 远程获取pprof数据 go func() { log.Println(http.ListenAndServe(&amp;quot;localhost:8080&amp;quot;, nil)) }  3. 应用程序 如果你的go程序只是一个应用程序，那就直接使用runtime/pprof包，具体用法是用pprof.StartCPUProfile和pprof.StopCPUProfile。
var cpuprofile = flag.String(&amp;quot;cpuprofile&amp;quot;, &amp;quot;&amp;quot;, &amp;quot;write cpu profile to file&amp;quot;) func main() { flag.Parse() if *cpuprofile != &amp;quot;&amp;quot; { f, err := os.</description>
    </item>
    
    <item>
      <title>Goroutine 运行原理</title>
      <link>https://realjf.io/golang/goroutine-principle/</link>
      <pubDate>Tue, 19 Mar 2019 14:45:21 +0800</pubDate>
      
      <guid>https://realjf.io/golang/goroutine-principle/</guid>
      <description>Golang最大的特色可以说是协程(goroutine)了, 协程让本来很复杂的异步编程变得简单, 让程序员不再需要面对回调地狱, 虽然现在引入了协程的语言越来越多, 但go中的协程仍然是实现的是最彻底的.
核心概念 要理解协程的实现，需要理解三个重要概念，P、G和M。
G（goroutine） G是goroutine的简写，goroutine可以解释为受管理的轻量级线程，goroutine使用go关键字创建。
main函数是一个主线程，也是一个goroutine。
 goroutine的新建、休眠、回复、停止都受到go运行时的管理 goroutine执行异步操作时会进入休眠状态，待操作完成后在恢复，无需占用系统线程。 goroutine新建或恢复时会添加到运行队列，等待M取出并运行。  M（machine） M是machine的简写，表示系统线程
M可以运行两种代码： - go代码，即goroutine，M运行go代码需要一个P - 原生代码，例如阻塞的syscall，M运行原生代码不需要P
 M运行时，会从G可运行队列中取出一个然后运行，如果G运行完毕或者进入休眠状态，则从可运行队列中取下一个G运行，周而复始。 有时候G需要调用一些无法避免阻塞的原生代码，这时M会释放持有的P并进入阻塞状态。其他M会取得这个P并继续运行队列中的G。  go需要保证有足够的M可以运行G，不让CPU闲着，也需要保证M的数量不过多。
P（process） P是process的简写，代表M运行G所需要的资源。
 虽然P的数量默认等于cpu的核心数，但可以通过环境变量 GOMAXPROC 修改，在实际运行时P跟cpu核心并无任何关联。
 P也可以理解为控制go代码的并行度的机制 - 如果P的数量等于1，代表当前最多只能有一个线程M执行go代码。 - 如果P的数量等于2，代表当前最多只能有两个线程M执行go代码。
执行原生代码的线程数不受P控制。
因为同一时间只有一个线程M可以拥有P，P中的数据都是锁自由的，读写这些数据的效率会非常的高。
数据结构 G的状态  空闲中(_Gidle)：表示G刚刚新建，仍未初始化 待运行(_Grunnable)：表示G在运行队列中，等待M取出并运行 运行中(_Grunning)：表示M正在运行这个G，这时候M会拥有一个P 系统调用中(_Gsyscall)：表示M正在运行这个G发起的系统调用，这时候M并不拥有P 等待中(_Gwaiting)：表示G在等待某些条件完成，这时候G不在运行也不在运行队列中（可能在channel的等待队列中） 已终止(_Gdead)：表示G未被使用，可能已执行完毕（并在freelist中等待下次复用） 栈复制中(_Gcopystack)：表示G正在获取一个新的栈空间并把原来的内容复制过去（用于防止GC扫描）  M的状态 M并没有像G和P一样的状态标记，但可以认为一个M有以下的状态： - 自旋中(spinning)：M正在从运行队列获取G，这时候M会拥有一个P - 执行go代码中：M正在执行go代码，这时候M会拥有一个P - 执行原生代码中：M正在执行原生代码或者阻塞的syscall，这时M并不拥有P - 休眠中：M发现没有待运行的G时会进入休眠，并添加到空闲M链表中，这时M并不拥有P
自旋中这个状态非常重要，是否需要唤醒或者创建新的M取决于当前自旋中的M的数量。
P的状态  空闲中(_Pidle)：当M发现无待运行的G时会进入休眠，这时M拥有的P会变成空闲并加到空闲P链表中 运行中(_Prunning)：当M拥有了一个P后，这个P的状态就会变为运行中，M运行G会使用这个P中的资源。 系统调用中(_Psyscall)：当go调用原生代码，原生代码又反过来调用go代码时，使用的P会变成此状态 GC停止中(_Pgcstop)：当gc停止整个世界(STW)时，P会变为此状态。 已终止(_Pdead)：当P的数量在运行时改变，且数量减少时多余的P会变为此状态。  本地可运行队列G 在go中有多个运行队列可以保存待运行(_Grunnable)的G，他们分别是各个P中的本地运行队列和全局运行队列。</description>
    </item>
    
  </channel>
</rss>