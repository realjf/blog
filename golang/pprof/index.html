<!doctype html>
<html>
  <head>
    <title>golang性能分析利器之Pprof // Real_JF&#39;s blog</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.54.0" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="realjf" />
    <meta name="description" content="" />
    <base href="https://realjf.io/" />
    <link rel="stylesheet" href="https://realjf.io/css/main.min.8bbf3ea8a23d56a9d7a5a59abe36f5ced638dcd0dcc27f86e1b20b174c446b68.css" />
  </head>
  <body>
    <header class="app-header">
      <a href="/"><img class="app-header-avatar" src="./avatar.jpg" /></a>
      <h1>Real_JF&#39;s blog</h1>
      <p>认识自己，接受自己，忘记自己，追随自己的灵魂</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/realjf"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
          <a target="_blank" href="https://twitter.com/realjf2"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-twitter">
  <path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>
</svg></a>
        
          <a target="_blank" href="http://realjf.com"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-activity">
  <polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">golang性能分析利器之Pprof</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Mar 19, 2019
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          2 min read
        </div></div>
    </header>
    <div class="post-content">
      

<p>pprof是golang程序一个性能分析的工具，可以查看堆栈、cpu信息等</p>

<p>pprof有2个包：net/http/pprof以及runtime/pprof</p>

<p>二者之间的关系：net/http/pprof包只是使用runtime/pprof包来进行封装了一下，并在http端口上暴露出来</p>

<h4 id="性能分析利器-pprof">性能分析利器 pprof</h4>

<p>go本身提供的工具链有：
- runtime/pprof：采集程序的运行数据进行分析
- net/http/pprof：采集HTTP Server的运行时数据进行分析</p>

<p>pprof以profile.proto读取分析样本的集合，并生成报告以可视化并帮助分析数据</p>

<blockquote>
<p>profile.proto是一个Protocol Buffer v3的描述文件，它描述了一组callstack和symbolization信息，作用是表示统计分析的一组采样的调用栈，是很常见的stacktrace配置文件格式</p>
</blockquote>

<h4 id="使用方式">使用方式</h4>

<ul>
<li>Report generation：报告生成</li>
<li>Interactive terminal use：交互式终端使用</li>
<li>Web interface：Web界面</li>
</ul>

<h5 id="1-web服务器方式">1. web服务器方式</h5>

<p>假如你的go呈现的是用http包启动的web服务器，当想要看web服务器的状态时，选择【net/http/pprof】，使用方法如下：</p>

<pre><code class="language-golang">&quot;net/http&quot;
_ &quot;net/http/pprof&quot;
</code></pre>

<p>查看结果：通过访问：<a href="http://domain:port/debug/pprof查看当前web服务的状态">http://domain:port/debug/pprof查看当前web服务的状态</a></p>

<h5 id="2-服务进程">2. 服务进程</h5>

<p>如果你go程序是一个服务进程，同样可以选择【net/http/pprof】包，然后开启另外一个goroutine来开启端口监听</p>

<pre><code class="language-golang">// 远程获取pprof数据
go func() {
    log.Println(http.ListenAndServe(&quot;localhost:8080&quot;, nil))
}
</code></pre>

<h5 id="3-应用程序">3. 应用程序</h5>

<p>如果你的go程序只是一个应用程序，那就直接使用runtime/pprof包，具体用法是用pprof.StartCPUProfile和pprof.StopCPUProfile。</p>

<pre><code class="language-golang">var cpuprofile = flag.String(&quot;cpuprofile&quot;, &quot;&quot;, &quot;write cpu profile to file&quot;)

func main() {
    flag.Parse()
    if *cpuprofile != &quot;&quot; {
        f, err := os.Create(*cpuprofile)
        if err != nil {
            log.Fatal(err)
        }
        pprof.StartCPUProfile(f)
        defer pprof.StopCPUProfile()
    }
}
</code></pre>

<h4 id="作用场景">作用场景</h4>

<ul>
<li>CPU Profiling：CPU分析，按照一定的频率采集所监听的应用程序CPU（含寄存器）的使用情况，可用于确定应用程序消耗cpu周期时花费时间的位置</li>
<li>Memory Profiling：内存分析，在应用程序进行堆分配时记录堆栈跟踪，用于监视当前和历史内存使用情况，以及检查内存泄漏。</li>
<li>Block Profiling：阻塞分析，记录goroutine阻塞等待同步（包括定时器通道）的位置</li>
<li>Mutex Profiling：互斥锁分析，报告互斥锁的竞争情况</li>
</ul>

<h3 id="分析">分析</h3>

<h4 id="通过web界面分析">通过web界面分析</h4>

<pre><code class="language-sh">http://localhost:8080/debug/pprof/
</code></pre>

<p>结果如下：</p>

<pre><code>/debug/pprof/

Types of profiles available:
Count   Profile
1   allocs
0   block
0   cmdline
14  goroutine
1   heap
0   mutex
0   profile
11  threadcreate
0   trace
full goroutine stack dump 
</code></pre>

<ul>
<li>allocs：过去所有的内存分配采样</li>
<li>block：Stack traces that led to blocking on synchronization primitives</li>
<li>cmdline：当前程序的命令行调用</li>
<li>goroutine：所有当前goroutine堆栈跟踪</li>
<li>heap：所有存活对象的内存分配采样。你可以在堆采样时指定gc GET参数来运行垃圾回收</li>
<li>mutex：争用互斥锁的拥有者堆栈跟踪</li>
<li>profile：CPU profile. You can specify the duration in the seconds GET parameter. After you get the profile file, use the go tool pprof command to investigate the profile.</li>
<li>threadcreate：引起创建新的操作系统线程的堆栈跟踪</li>
<li>trace：对当前程序执行的跟踪。可以在seconds get参数中指定持续时间。获取跟踪文件后，使用go tool trace命令调查跟踪</li>
<li>full groutine stack dump：</li>
</ul>

<h4 id="实例分析">实例分析</h4>

<pre><code class="language-golang">package main

import (
    &quot;flag&quot;
    &quot;log&quot;
    &quot;net/http&quot;
    _ &quot;net/http/pprof&quot;
    &quot;sync&quot;
    &quot;time&quot;
)

func Counter(wg *sync.WaitGroup) {
    time.Sleep(time.Second)

    var counter int
    for i := 0; i &lt; 1000000; i++ {
        time.Sleep(time.Millisecond * 200)
        counter++
    }
    wg.Done()
}

func main() {
    flag.Parse()

    //远程获取pprof数据
    go func() {
        log.Println(http.ListenAndServe(&quot;localhost:8080&quot;, nil))
    }()

    var wg sync.WaitGroup
    wg.Add(10)
    for i := 0; i &lt; 10; i++ {
        go Counter(&amp;wg)
    }
    wg.Wait()

    // sleep 10mins, 在程序退出之前可以查看性能参数.
    time.Sleep(60 * time.Second)
}

</code></pre>

    </div>
  </article>

    </main>
  </body>
</html>
