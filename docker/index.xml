<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Dockers on Realjf&#39;s blog</title>
    <link>https://realjf.io/docker/</link>
    <description>Recent content in Dockers on Realjf&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 07 Jun 2021 09:09:23 +0800</lastBuildDate>
    
	<atom:link href="https://realjf.io/docker/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Dockerfile手册 Dockerfile Reference</title>
      <link>https://realjf.io/docker/dockerfile-reference/</link>
      <pubDate>Mon, 07 Jun 2021 09:09:23 +0800</pubDate>
      
      <guid>https://realjf.io/docker/dockerfile-reference/</guid>
      <description>[toc]
.dockerignore 文件 # comment */temp* */*/temp* temp?     规则 行为     # comment 忽略   */temp * 排除以temp开头的文件和当前目录的子目录，如：/somedir/temporary.txt   * / * /temp* 排除以temp开头的文件和两级子目录，如：/somedir/subdir/temporary.txt   temp ? 排除以temp扩展一个字母的文件和目录，如：/tempa,tempb等    FROM FROM [--platform=&amp;lt;platform&amp;gt;] &amp;lt;image&amp;gt; [AS &amp;lt;name&amp;gt;] # or FROM [--platform=&amp;lt;platform&amp;gt;] &amp;lt;image&amp;gt;[:&amp;lt;tag&amp;gt;] [AS &amp;lt;name&amp;gt;] # or FROM [--platform=&amp;lt;platform&amp;gt;] &amp;lt;image&amp;gt;[@&amp;lt;digest&amp;gt;] [AS &amp;lt;name&amp;gt;]  FROM 指令初始化一个新的构建阶段并为后续指令设置基础镜像。因此，有效的 Dockerfile 必须以 FROM 指令开头。镜像可以是任何有效的镜像——从公共存储库中提取镜像特别容易。
 ARG 是 Dockerfile 中可能位于 FROM 之前的唯一指令。请参阅了解 ARG 和 FROM 如何交互。 FROM 可以在单个 Dockerfile 中多次出现以创建多个镜像或使用一个构建阶段作为另一个构建阶段的依赖项。只需记下每个新 FROM 指令之前提交的最后一个镜像 ID 输出。每个 FROM 指令都会清除由先前指令创建的任何状态。 可以选择通过将 AS name 添加到 FROM 指令来为新的构建阶段指定名称。该名称可用于后续的 FROM 和 COPY &amp;ndash;from= 指令以引用在此阶段构建的映像。 tag 或 digest 值是可选的。如果您省略其中任何一个，构建器默认采用 latest 标签。如果构建器找不到标签值，它会返回一个错误。  可选的 &amp;ndash;platform 标志可用于在 FROM 引用多平台图像的情况下指定图像的平台。例如，linux/amd64、linux/arm64 或 windows/amd64。默认情况下，使用构建请求的目标平台。全局构建参数可用于此标志的值，例如自动平台 ARG 允许您强制一个阶段到本机构建平台（&amp;ndash;platform=$BUILDPLATFORM），并使用它交叉编译到内部的目标平台阶段。</description>
    </item>
    
    <item>
      <title>docker error creating overlay mount to invalid argument 解决方法</title>
      <link>https://realjf.io/docker/docker-create-layer-error/</link>
      <pubDate>Tue, 28 Apr 2020 15:29:31 +0800</pubDate>
      
      <guid>https://realjf.io/docker/docker-create-layer-error/</guid>
      <description> 原因 由于docker的不同版本在centos上产生的mount问题，1.2.x没有出现这个问题，当使用yum install时，安装的最新版本(1.3.x)，会导致overlay2的错误。
解决方法 修改docker启动参数storage-driver
vim /etc/sysconfig/docker-storage # 将文件中的DOCKER_STORAGE_OPTIONS=&amp;quot;-s overlay2&amp;quot;修改为DOCKER_STORAGE_OPTIONS=&amp;quot;-s overlay&amp;quot;  然后重新加载daemon
systemctl daemon-reload  重启docker
systemctl restart docker  </description>
    </item>
    
    <item>
      <title>Dockerfile实现修改容器hosts文件内容</title>
      <link>https://realjf.io/docker/docker-modify-hosts/</link>
      <pubDate>Tue, 28 Apr 2020 15:26:44 +0800</pubDate>
      
      <guid>https://realjf.io/docker/docker-modify-hosts/</guid>
      <description>场景 今天突然遇到一个问题，需要向容器的/etc/hosts文件追加自定义的内容，直接的做法的是，进入容器，直接修改/etc/hosts文件，但是，这种做法在容器重新启动后就失效，而且容器启动实例一多，就会带来繁琐的手动操作。
为了能让同一个镜像启动的容器每次启动的时候都能自动更新成我们需要的/etc/hosts文件，现有以下几种方法：
1. 在docker run的时候增加参数&amp;ndash;add-host进行添加（官方给的方法） # 添加单个hosts docker run -it nginx --add-host=localhost:127.0.0.1 # 添加多个hosts docker run -it nginx --add-host=localhost:127.0.0.1 --add-host=example.com:127.0.0.1 # 一个ip对应多个hosts docker run -it nginx --add-host=&amp;quot;localhost example.com&amp;quot;:127.0.0.1  2. 在dockerfile中，使用脚本作为镜像入口，再利用脚本运行修改hosts文件的命令以及真正的应用程序入口 文件说明 - myhosts：需要追加到/etc/hosts中的内容 - run.sh：容器的入口执行脚本 - dockerfile：构建镜像的dockerfile文件
dockerfile示例如下：
FROM centos:6 MAINTAINER chenjiefeng COPY run.sh ~/run.sh COPY myhosts ~/myhosts RUN chmod +x ~/run.sh ENTRYPOINT /bin/sh -c ~/run.sh  run.sh示例如下：
#!/bin/bash # 向hosts文件追加内容 cat ~/myhosts &amp;gt;&amp;gt; /etc/hosts # 其他命令 # 保留终端，防止容器自动退出 /bin/bash  myhosts示例如下：</description>
    </item>
    
    <item>
      <title>Docker容器和宿主机时间不一致问题解决</title>
      <link>https://realjf.io/docker/docker-time-sync/</link>
      <pubDate>Tue, 28 Apr 2020 15:26:29 +0800</pubDate>
      
      <guid>https://realjf.io/docker/docker-time-sync/</guid>
      <description> 1. 在Dockerfile中解决（永久性，推荐） 在Dockerfile文件中加上如下：
ENV TZ=Asia/Shanghai # 添加你需要的时区 RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;amp;&amp;amp; echo $TZ &amp;gt; /etc/timezone  2. 临时性设置 在container的shell交互里输入
TZ=Asia/Shanghai ln -snf /usr/share/zoneinfo/$TZ /etc/localtime &amp;amp;&amp;amp; echo $TZ &amp;gt; /etc/timezone ## 检查时间 date  </description>
    </item>
    
  </channel>
</rss>