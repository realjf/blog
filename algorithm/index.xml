<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Algorithms on Realjf&#39;s blog</title>
    <link>https://realjf.io/algorithm/</link>
    <description>Recent content in Algorithms on Realjf&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 28 Apr 2020 15:03:27 +0800</lastBuildDate>
    
	<atom:link href="https://realjf.io/algorithm/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>排序算法之选择排序 Select Sort</title>
      <link>https://realjf.io/algorithm/sort/select-sort/</link>
      <pubDate>Tue, 28 Apr 2020 15:03:27 +0800</pubDate>
      
      <guid>https://realjf.io/algorithm/sort/select-sort/</guid>
      <description>选择排序算法是每次循环遍历出未排除中最小值的位置，然后与将其与未排序部分第一个元素进行交换
#include &amp;lt;stdio.h&amp;gt; void swap(int* a, int* b) { if(*a &amp;gt; *b){ *a = *a + *b; *b = *a - *b; *a = *a - *b; } } int main(){ int a[10],i,j; for(i=0;i&amp;lt;10;i++){ scanf(&amp;#34;%d&amp;#34;, &amp;amp;a[i]); } for(i=0;i&amp;lt;9;i++){ int min = i; for(j=i+1;j&amp;lt;10;j++){ if(a[j] &amp;lt; a[min]){ min = j; } } swap(&amp;amp;a[min], &amp;amp;a[i]); } return 0; } </description>
    </item>
    
    <item>
      <title>排序算法之归并排序 Merge Sort</title>
      <link>https://realjf.io/algorithm/sort/merge-sort/</link>
      <pubDate>Tue, 28 Apr 2020 15:03:19 +0800</pubDate>
      
      <guid>https://realjf.io/algorithm/sort/merge-sort/</guid>
      <description>归并排序的基本思想是：
 将给定的包含n个元素的局部数组“分割”成两个局部数组，每个数组各包含n/2各元素。 对两个局部数组分别执行mergeSort排序。 通过merge将两个已排序完毕的局部数组整合成一个数组。  #inlcude &amp;lt;iostream&amp;gt; using namespace std; #define MAX 500000 #define SENTINEL 2000000000  int L[MAX/2+2], R[MAX/2+2]; int cnt; void merge(int A[], int n, int left, int mid, int right){ int n1 = mid - left; int n2 = right - mid; for(int i=0; i&amp;lt; n1; i++)L[i] = A[left+i]; for(int i = 0; i&amp;lt; n2;i++) R[i] = A[mid+i]; L[n1] = R[n2] = SENTINEL; int i = 0; j = 0; for(int k = left; k&amp;lt;right;k++){ cnt++; if(L[i]&amp;lt;=R[j]){ A[k] = L[i++]; }else{ A[k] = R[j++]; } } } void mergeSort(int A[], int n, int left, int right){ if(left+1 &amp;lt; right){ int mid = (left + right) / 2; mergeSort(A, n, left, mid); mergeSort(A, n, mid, right); merge(A, n, left, mid, right); } } int main(){ int A[MAX], n, i; cnt = 0; cin &amp;gt;&amp;gt; n; for(i = 0; i&amp;lt;n; i++) cin&amp;gt;&amp;gt;A[i]; mergeSort(A, n, 0, n); for(i=0; i&amp;lt;n; i++){ if(i) cout &amp;lt;&amp;lt; &amp;#34; &amp;#34;; cout &amp;lt;&amp;lt; A[i]; } cout &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; cnt &amp;lt;&amp;lt; endl; return 0; } </description>
    </item>
    
    <item>
      <title>排序算法之插入排序 Insert Sort</title>
      <link>https://realjf.io/algorithm/sort/insert-sort/</link>
      <pubDate>Tue, 28 Apr 2020 15:03:02 +0800</pubDate>
      
      <guid>https://realjf.io/algorithm/sort/insert-sort/</guid>
      <description>插入排序是简单的说，就是遍历整个数组，每次将一个元素插入到已排序的数组中，直到插入最后一个元素即完成整个排序过程。
基本思想  将开头第一个元素视作已排序部分，后续元素视作未排序部分 对未排序部分执行一下操作，直到未排序部分被消除  取出未排序部分开头第一个元素作为待排序元素t 将t与已排序部分进行对比，将比t顺序大的元素往后移动一个，即确定排序位置 将待排序元素t插入空出的排序位置中    #include &amp;lt;stdio.h&amp;gt;int main(){ int a[10],i,j; for(i=0;i&amp;lt;10;i++){scanf(&amp;#34;%d&amp;#34;, &amp;amp;a[i]);} for (i=1;i&amp;lt;10;i++){ int t = a[i]; // 待排序元素  j = i-1; while(j&amp;gt;=0 &amp;amp;&amp;amp; a[j] &amp;gt; t){ a[j+1] = a[j]; // 往后移动一个  j--; } a[j+1] = t; // 插入  } for(i=0; i&amp;lt;10;i++){ printf(&amp;#34;%d &amp;#34;, a[i]); } } 插入排序算法最坏的情况时间复杂度也是O(n^2)</description>
    </item>
    
    <item>
      <title>排序算法之冒泡排序 Bubble Sort</title>
      <link>https://realjf.io/algorithm/sort/bubble-sort/</link>
      <pubDate>Tue, 28 Apr 2020 15:00:51 +0800</pubDate>
      
      <guid>https://realjf.io/algorithm/sort/bubble-sort/</guid>
      <description>冒泡排序算法很简单，对相邻的元素进行两两比较，顺序相反则进行交换，这样，每一趟会将最小或最大的元素“浮”到顶端，最终达到完全有序。
基本思想： 1.
#include &amp;lt;stdio.h&amp;gt;void swap(int* a, int* b){ if(*a &amp;gt; &amp;amp;b){ *a = *a+*b; *b = *a-*b; *a = *a-*b; } return; } int main(){ int a[10],i,j; for(i=0;i&amp;lt;10;i++){scanf(&amp;#34;%d&amp;#34;, &amp;amp;a[i]);} for (i=0;i&amp;lt;10;i++){ for(j=0; j&amp;lt;i; j++){ swap(&amp;amp;a[i], &amp;amp;a[j]); } } for(i=0; i&amp;lt;10;i++){ printf(&amp;#34;%d&amp;#34;, a[i]); } } 由以上程序可以看出，程序的时间复杂度是O(n^2)</description>
    </item>
    
  </channel>
</rss>